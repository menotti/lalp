/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. ALPParser.jj */
/*@egen*//* Copyright (c) 2009 Jo\u221a\u00a3o M. P. Cardoso <jmpc@acm.org>, All Rights Reserved.
 * Copyright (c) 2009 Ricardo Menotti <ricardomenotti@acm.org>, All Rights Reserved.
 *
 * Permission to use, copy, modify, and distribute this software and its 
 * documentation for NON-COMERCIAL purposes and without fee is hereby granted 
 * provided that this copyright notice appears in all copies.
 *
 * RICARDO MENOTTI MAKES NO REPRESENTATIONS OR WARRANTIES ABOUT THE SUITABILITY
 * OF THE SOFTWARE, EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE 
 * IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, OR 
 * NON-INFRINGEMENT. RICARDO MENOTTI SHALL NOT BE LIABLE FOR ANY DAMAGES 
 * SUFFERED BY LICENSEE AS A RESULT OF USING, MODIFYING OR DISTRIBUTING THIS 
 * SOFTWARE OR ITS DERIVATIVES. 
 */

options {
    LOOKAHEAD=1;
    IGNORE_CASE=true;
    STATIC = false;
                          
}

//TODO check duplicated Variable/Pin names

PARSER_BEGIN(ALPParser)
/* Copyright (c) 2009 Jo\u221a\u00a3o M. P. Cardoso <jmpc@acm.org>, All Rights Reserved.
 * Copyright (c) 2009 Ricardo Menotti <ricardomenotti@acm.org>, All Rights Reserved.
 *
 * Permission to use, copy, modify, and distribute this software and its 
 * documentation for NON-COMERCIAL purposes and without fee is hereby granted 
 * provided that this copyright notice appears in all copies.
 *
 * RICARDO MENOTTI MAKES NO REPRESENTATIONS OR WARRANTIES ABOUT THE SUITABILITY
 * OF THE SOFTWARE, EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE 
 * IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, OR 
 * NON-INFRINGEMENT. RICARDO MENOTTI SHALL NOT BE LIABLE FOR ANY DAMAGES 
 * SUFFERED BY LICENSEE AS A RESULT OF USING, MODIFYING OR DISTRIBUTING THIS 
 * SOFTWARE OR ITS DERIVATIVES. 
 */

package alp.parser.lang;

import java.util.*;

import alp.core.*;
import alp.components.*;

/**
 * @author <a href="mailto:ricardomenotti@acm.org">Ricardo Menotti</a>
 * @author <a href="http://www.icmc.usp.br/~menotti/">ICMC/USP</a>
 * @author <a href="http://www.cm.utfpr.edu.br/menotti/">UTFPR</a>
 * @version January, 2009
 */
 
@SuppressWarnings("unchecked") 
public class ALPParser/*@bgen(jjtree)*/implements ALPParserTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected JJTALPParserState jjtree = new JJTALPParserState();

/*@egen*/

	public Design design;
	public Hashtable<String, Integer> allConsts = new Hashtable<String, Integer>();
	public Hashtable<String, Integer> allTypedefs = new Hashtable<String, Integer>();
	public Hashtable<String, SimpleNode> allPins = new Hashtable<String, SimpleNode>();
	public Hashtable<String, SimpleNode> allVariables = new Hashtable<String, SimpleNode>();
	public Hashtable<String, Integer> allAttribution = new Hashtable<String, Integer>();
	public TreeMap<Integer, String> allAttributionLines = new TreeMap<Integer, String>();

/*	public static void main(String args[]) {
		FileInputStream inStream;
		if (args.length == 0) {
			System.out.println("usage: java RunFile <input_file>");
			System.exit(1);
		} else if (args.length != 1) {
			System.out.println("usage: java RunFile <input_file>");
			System.exit(1);
		}
		try {
			System.out.println("parsing: Reading from file " + args[0] + "...");
			inStream = new FileInputStream(args[0]);
			ALPParser parser = new ALPParser(inStream);
			SimpleNode root = parser.Start();
		} catch (FileNotFoundException e) {
			System.out.println("parsing:  File " + args[0] + " not found.");
			System.exit(1);
		} catch (Exception e) {
			e.printStackTrace();
			System.exit(1);
		}
	}*/
}

PARSER_END(ALPParser)

/* WHITE SPACE */
SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
| "\f"
}

/* COMMENTS */
MORE :
{
  "//" : IN_SINGLE_LINE_COMMENT
|  <"/**" ~["/"]> { input_stream.backup(1); } : IN_FORMAL_COMMENT
|  "/*" : IN_MULTI_LINE_COMMENT
}

<IN_SINGLE_LINE_COMMENT>
SPECIAL_TOKEN :
{
  <SINGLE_LINE_COMMENT: "\n" | "\r" | "\r\n" > : DEFAULT
}

<IN_FORMAL_COMMENT>
SPECIAL_TOKEN :
{
  <FORMAL_COMMENT: "*/" > : DEFAULT
}

<IN_MULTI_LINE_COMMENT>
SPECIAL_TOKEN :
{
  <MULTI_LINE_COMMENT: "*/" > : DEFAULT
}

<IN_SINGLE_LINE_COMMENT,IN_FORMAL_COMMENT,IN_MULTI_LINE_COMMENT>
MORE :
{
  < ~[] >
}

/* reserved words */
TOKEN: {
	< TYPEDEF: "typedef" >
	| < FIXED: "fixed" >
	| < IN: "in" >
	| < OUT: "out" >
	| < CONST: "const">
	| < COUNTER: "counter">
	| < WHEN: "when">
 }
 

TOKEN : /* LITERALS */
{
  < INTEGER_LITERAL:
        ("-")? <DECIMAL_LITERAL> (["l","L"])?
      | ("-")? <HEX_LITERAL> (["l","L"])?
  >
|
  < #DECIMAL_LITERAL: (["0"-"9"])+ >
|
  < #HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+ >
|
  < CHARACTER_LITERAL:
      "'"
      (   (~["'","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            )
          )
      )
      "'"
  >
|
  < STRING_LITERAL:
      "\""
      (   (~["\"","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            )
          )
      )*
      "\""
  >
}

TOKEN : /* IDENTIFIERS */
{
  < IDENTIFIER: <LETTER> (<LETTER>|<DIGIT>)* >
|
  < #LETTER:
      [
       "$",
       "A"-"Z",
       "_",
       "a"-"z",
       "\u00c0"-"\u00d6",
       "\u00d8"-"\u00f6",
       "\u00f8"-"\u00ff",
       "\u0100"-"\u1fff",
       "\u3040"-"\u318f",
       "\u3300"-"\u337f",
       "\u3400"-"\u3d2d",
       "\u4e00"-"\u9fff",
       "\uf900"-"\ufaff"
      ]
  >
|
  < #DIGIT:
      [
       "0"-"9",
       "\u0660"-"\u0669",
       "\u06f0"-"\u06f9",
       "\u0966"-"\u096f",
       "\u09e6"-"\u09ef",
       "\u0a66"-"\u0a6f",
       "\u0ae6"-"\u0aef",
       "\u0b66"-"\u0b6f",
       "\u0be7"-"\u0bef",
       "\u0c66"-"\u0c6f",
       "\u0ce6"-"\u0cef",
       "\u0d66"-"\u0d6f",
       "\u0e50"-"\u0e59",
       "\u0ed0"-"\u0ed9",
       "\u1040"-"\u1049"
      ]
  >
}
 
TOKEN :
{
	  < LPAREN: "(" >
	| < RPAREN: ")" >
	| < LBRACE: "{" >
	| < RBRACE: "}" >
	| < LBRACKET: "[" >
	| < RBRACKET: "]" >
	| < SEMICOLON: ";" >
	| < COMMA: "," >
	| < DOT: "." >
}

TOKEN : /* OPERATORS */
{
  < ASSIGN: "=" >
| < AT: "@" >
| < GT: ">" >
| < LT: "<" >
| < BANG: "!" >
| < TILDE: "~" >
| < HOOK: "?" >
| < COLON: ":" >
| < EQ: "==" >
| < LE: "<=" >
| < GE: ">=" >
| < NE: "!=" >
| < SC_OR: "||" >
| < SC_AND: "&&" >
| < INCR: "++" >
| < DECR: "--" >
| < PLUS: "+" >
| < MINUS: "-" >
| < STAR: "*" >
| < SLASH: "/" >
| < BIT_AND: "&" >
| < BIT_OR: "|" >
| < XOR: "^" >
| < REM: "%" >
| < LSHIFT: "<<" >
| < RSIGNEDSHIFT: ">>" >
| < RUNSIGNEDSHIFT: ">>>" >
| < PLUSASSIGN: "+=" >
| < MINUSASSIGN: "-=" >
| < STARASSIGN: "*=" >
| < SLASHASSIGN: "/=" >
| < ANDASSIGN: "&=" >
| < ORASSIGN: "|=" >
| < XORASSIGN: "^=" >
| < REMASSIGN: "%=" >
| < LSHIFTASSIGN: "<<=" >
| < RSIGNEDSHIFTASSIGN: ">>=" >
| < RUNSIGNEDSHIFTASSIGN: ">>>=" >
}


SimpleNode Start() : {/*@bgen(jjtree) Start */
        SimpleNode jjtn000 = new SimpleNode(this, JJTSTART);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	Token t;
}
{/*@bgen(jjtree) Start */
        try {
/*@egen*/
 	(Const())* 
 	(Typedef())* 
 	t=<IDENTIFIER>
 	{
 		jjtn000.setIdentifier(t.image);
 	}
 	<LPAREN> (Pin() (<COMMA> Pin())*)? <RPAREN> 
 	<LBRACE> Statements() <RBRACE>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
 		return jjtn000;
 	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Name() : {/*@bgen(jjtree) Name */
        SimpleNode jjtn000 = new SimpleNode(this, JJTNAME);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	Token tName, tPort = null;
}
{/*@bgen(jjtree) Name */
        try {
/*@egen*/
	tName=<IDENTIFIER> (<DOT> tPort=<IDENTIFIER>)?/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		if (allVariables.containsKey(tName.image) || allConsts.containsKey(tName.image) || allPins.containsKey(tName.image)) {
			jjtn000.setIdentifier(tName.image);
			//jjtThis.setComponentClass(loop.components.reg_op.class);
			if (tPort != null) {
				jjtn000.setPort(tPort.image);
			}
		}
		else {
			ErrorToken("Variable/Pin " + tName.image + " NOT found!", tName);
		}
	}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Const() : {/*@bgen(jjtree) Const */
        SimpleNode jjtn000 = new SimpleNode(this, JJTCONST);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	Token constName, constVal;
}
{/*@bgen(jjtree) Const */
        try {
/*@egen*/
	<CONST> constName=<IDENTIFIER> "=" constVal=<INTEGER_LITERAL> <SEMICOLON>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		if (allConsts.containsKey(constName.image)) {
			ErrorToken("Redefinition of Const " + constName.image, constName);
		}
		allConsts.put(constName.image, StringToInteger(constVal.image));
		jjtn000.setIdentifier(constName.image);
		jjtn000.jjtSetValue(StringToInteger(constVal.image));
		//jjtThis.setComponentClass(loop.components.const_op.class);
		//DEBUG
		//InfoToken("Const " + constName.image + " with value " + constVal.image + " found", constName);
	}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Typedef() : {/*@bgen(jjtree) Typedef */
        SimpleNode jjtn000 = new SimpleNode(this, JJTTYPEDEF);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	Token typedefName;
	int typedefVal;
}
{/*@bgen(jjtree) Typedef */
        try {
/*@egen*/
	<TYPEDEF> typedefVal=Fixed() typedefName=<IDENTIFIER> <SEMICOLON>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
 	{
 		if (allTypedefs.containsKey(typedefName.image)) {
			ErrorToken("Redefinition of Typedef " + typedefName.image, typedefName);
		}
 		allTypedefs.put(typedefName.image, typedefVal);
		jjtn000.setIdentifier(typedefName.image);
		jjtn000.setWidth(typedefVal);
		//DEBUG
		//InfoToken("Type " + typedefName.image + " with " + typedefVal + " bit(s) found", typedefName);
 	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

int Fixed()       : {
	int bitwidth;
}
{
	<FIXED> <LPAREN> bitwidth=ConstOrInt() <COMMA> ConstOrInt() (<COMMA> ConstOrInt())? <RPAREN>
	{
		return bitwidth;
	}
}

void Pin() : {/*@bgen(jjtree) Pin */
        SimpleNode jjtn000 = new SimpleNode(this, JJTPIN);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	Token pinDir, pinName, pinType=null;
	int pinWidth=0;
}
{/*@bgen(jjtree) Pin */
        try {
/*@egen*/
	(pinDir=<IN> | pinDir=<OUT>) (pinType=<IDENTIFIER> | pinWidth=Fixed()) pinName=<IDENTIFIER>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		if (pinType != null) {
			if (allTypedefs.containsKey(pinType.image)) {
				pinWidth=(Integer)(allTypedefs.get(pinType.image));
				//DEBUG
				//InfoToken(pinDir.image + "put pin " + pinName.image + " of type " + pinType.image + " found", pinName);
			}
			else {
				ErrorToken("Type " + pinType.image + " NOT found!", pinType);
			}
		}
		else {
			//DEBUG
			//InfoToken(pinDir.image + "put pin " + pinName.image + " of size " + pinWidth + " found", pinName);
		}
		jjtn000.setIdentifier(pinName.image);
		jjtn000.setWidth(pinWidth);		
		allPins.put(pinName.image, jjtn000);
		if (pinDir.kind == IN) {
			jjtn000.setPortType(PortType.INPUT);
		}
		else {
			jjtn000.setPortType(PortType.OUTPUT);
		}
		//allComponents.put(pinName.image, comp);
		//jjtThis.setComponent(comp);
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Statements()       : {}
{
 	 (Declarations())?
 	 (Statement())+
}

void Declarations()       : {}
{
 	 <LBRACE> (Declaration())+ <RBRACE>
}

void Declaration()       : {
	Token varType=null;
	int varWidth=0;
}
{
	(varType=<IDENTIFIER> | varWidth=Fixed()) 
	{
		if (varType != null) {
			if (allTypedefs.containsKey(varType.image)) {
				varWidth=(Integer)(allTypedefs.get(varType.image));
			}
			else {
				ErrorToken("Type " + varType.image + " NOT found!", varType);
			}
		}
	}
	(Variable(varWidth)) ("," (Variable(varWidth)))* <SEMICOLON>
}

void Variable(int varWidth) : {/*@bgen(jjtree) Variable */
        SimpleNode jjtn000 = new SimpleNode(this, JJTVARIABLE);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	Token tName;
	Integer size = null;
	Long init = null;
	Vector<Long> inits = null;
}
{/*@bgen(jjtree) Variable */
        try {
/*@egen*/
	tName=<IDENTIFIER> (<LBRACKET> (size=ConstOrInt())? <RBRACKET>)? ("=" (init=ConstOrLong() | inits=MemoryInit(inits)))?/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		if (allVariables.containsKey(tName.image)) {
			ErrorToken("Redefinition of Variable " + tName.image, tName);
		}
		jjtn000.setIdentifier(tName.image);
		if (size == null && inits != null && inits.size() != 0)
			size = inits.size();
		jjtn000.setArraySize(size);
		jjtn000.jjtSetValue(init);
		jjtn000.setInits(inits);
		jjtn000.setWidth(varWidth);
		jjtn000.setToken(tName);
		allVariables.put(tName.image, jjtn000);
		// comp = design.addComponent(comp);
		// jjtThis.setComponent(comp);
		// allComponents.put(tName.image, comp);
		//DEBUG 
		//InfoToken("Variable " + tName.image + (size>0 ? "[" + size +"]" : "") + (init != null ? " with initial value " + init : "") +" found", tName);
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

Vector<Long> MemoryInit(Vector<Long> inits)       : {
	Token t1, t2=null;
}
{
	"{" t1=<INTEGER_LITERAL>
	{
		if (inits == null) {
			inits = new Vector<Long>();
		}
		inits.add(StringToLong(t1.image));
	}
	( "," t2=<INTEGER_LITERAL>
	{
		if (t2 != null) {
			inits.add(StringToLong(t2.image));
		}
	}
	)* "}"
	{
		return inits;
	}
}

void Counter() : {/*@bgen(jjtree) Counter */
        SimpleNode jjtn000 = new SimpleNode(this, JJTCOUNTER);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	
	Token tVarInit, iLoad=null, vLoad=null;
	
	Token tVarTerm, iTerm=null, vTerm=null;
	String termCond;
	
	Token tVarInc, tIncOper;
	Integer steps = 1, increment = 1;
	
}
{/*@bgen(jjtree) Counter */
        try {
/*@egen*/
	<COUNTER> <LPAREN> 
		
	(tVarInit=<IDENTIFIER> "=" (iLoad=<INTEGER_LITERAL> | vLoad=<IDENTIFIER>))
	{
		if (!allVariables.containsKey(tVarInit.image)) {
			ErrorToken("Variable " + tVarInit.image + " NOT found!", tVarInit);
		}		
		if (iLoad != null) { //literal initialization
			jjtn000.setLoad(StringToInteger(iLoad.image));
		}
		else if (allConsts.containsKey(vLoad.image)) { //constant initialization
			jjtn000.setLoad(new Integer(allConsts.get(vLoad.image)));
		}
		else if (allVariables.containsKey(vLoad.image)) { //variable initialization
			jjtn000.setLoad(allVariables.get(vLoad.image));
		}
		else {
			ErrorToken("Constant/Variable "+vLoad.image+" NOT found!", vLoad);
		}
		jjtn000.setIdentifier(tVarInit.image);
		allAttribution.put(tVarInit.image, tVarInit.beginLine);
		//allVariables.put(tVarInit.image, jjtThis);	
	}
	
	<SEMICOLON> 
	
	(tVarTerm=<IDENTIFIER> termCond=CounterComp() (iTerm=<INTEGER_LITERAL> | vTerm=<IDENTIFIER>))
	{
		if (iTerm != null) { //literal initialization
			jjtn000.setTerm(StringToInteger(iTerm.image));
		}
		else if (allConsts.containsKey(vTerm.image)) { //constant initialization
			jjtn000.setTerm(new Integer(allConsts.get(vTerm.image)));
		}
		else if (allVariables.containsKey(vTerm.image)) { //variable initialization
			jjtn000.setTerm(allVariables.get(vTerm.image));
		}
		else {
			ErrorToken("Constant/Variable "+vTerm.image+" NOT found!", vTerm);
		}
		jjtn000.setTermCond(termCond);
	}
	
	<SEMICOLON> 
	
	(tVarInc=<IDENTIFIER> (tIncOper="++" | tIncOper="--" | tIncOper="+=" increment=ConstOrInt() | tIncOper="-=" increment=ConstOrInt()) (<AT> steps=ConstOrInt())?)
	{
		jjtn000.setIncOper(tIncOper.image);
		jjtn000.setStepDelay(steps);
		jjtn000.setInc(increment);
	}
	
	<RPAREN>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	
	{
		if (!(tVarInit.image.equals(tVarTerm.image) && tVarTerm.image.equals(tVarInc.image))) {
			System.out.println("Counter Initialization/Termination/Increment must use the same variable");
			System.exit(1);
		}
		String incOper=tIncOper.image;
		if (incOper.charAt(0)=='-') {
			jjtn000.setCounterDown(true);
		}						
		jjtn000.setComponentClass(counter.class);		
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

String CounterComp()       : {
	Token t;
}
{
	(t="<" | t="<=" | t=">" | t=">=" | t="==" | t="!=")
	{
		return t.image;
	}
}

void Statement()       : {}
{
	(Assignment() | Counter()) <SEMICOLON>
}

void Assignment() : {/*@bgen(jjtree) Assignment */
        SimpleNode jjtn000 = new SimpleNode(this, JJTASSIGNMENT);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	String operator = null;
}
{/*@bgen(jjtree) Assignment */
        try {
/*@egen*/
	LHS() operator=AssignmentOperator() RHS() (When())?/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{		
		jjtn000.setIdentifier(operator);
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void When() : {/*@bgen(jjtree) When */
  SimpleNode jjtn000 = new SimpleNode(this, JJTWHEN);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) When */
        try {
/*@egen*/
	<WHEN> Expression()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void LHS() : {/*@bgen(jjtree) LHS */
        SimpleNode jjtn000 = new SimpleNode(this, JJTLHS);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	Token tName, tPort = null;
}
{/*@bgen(jjtree) LHS */
        try {
/*@egen*/
	tName=<IDENTIFIER> (<DOT> tPort=<IDENTIFIER>)?/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		if (allVariables.containsKey(tName.image) || allPins.containsKey(tName.image)) {
			jjtn000.setIdentifier(tName.image);
			//jjtThis.setComponentClass(loop.components.reg_op.class);
			if (tPort != null) {
				jjtn000.setPort(tPort.image);
			}
			allAttribution.put(tName.image, tName.beginLine);
			allAttributionLines.put(tName.beginLine, tName.image);
		}
		else {
			ErrorToken("Variable/Pin " + tName.image + " NOT found!", tName);
		}
	}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

String AssignmentOperator()       : {
	Token t;
}
{
	( t="=" 
	| t="*=" 
	| t="/=" 
	| t="%=" 
	| t="+=" 
	| t="-=" 
	| t="<<=" 
	| t=">>=" 
	| t=">>>=" 
	| t="&=" 
	| t="^=" 
	| t="|=")
	{
		return t.image;
	}
}

void RHS() : {/*@bgen(jjtree) RHS */
  SimpleNode jjtn000 = new SimpleNode(this, JJTRHS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) RHS */
        try {
/*@egen*/
	Expression()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Expression() : {/*@bgen(jjtree) Expression */
  SimpleNode jjtn000 = new SimpleNode(this, JJTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Expression */
        try {
/*@egen*/
	DelayExpression()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void DelayExpression() : {/*@bgen(jjtree) DelayExpression */
        SimpleNode jjtn000 = new SimpleNode(this, JJTDELAYEXPRESSION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	Integer amount = null;
}
{/*@bgen(jjtree) DelayExpression */
        try {
/*@egen*/
	ConditionalExpression() (
	LOOKAHEAD(1) {jjtn000.setComponentClass(delay_op.class);} 
	"@" amount=ConstOrInt() {jjtn000.setStepDelay(amount);} 
	)?/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void ConditionalExpression() : {/*@bgen(jjtree) ConditionalExpression */
  SimpleNode jjtn000 = new SimpleNode(this, JJTCONDITIONALEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ConditionalExpression */
  try {
/*@egen*/
  ConditionalOrExpression() [ "?" {jjtn000.setComponentClass(reg_mux_op.class);} ConditionalOrExpression() ":" ConditionalOrExpression() ]/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void ConditionalOrExpression() : {/*@bgen(jjtree) ConditionalOrExpression */
  SimpleNode jjtn000 = new SimpleNode(this, JJTCONDITIONALOREXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ConditionalOrExpression */
  try {
/*@egen*/
  ConditionalAndExpression() ( {jjtn000.setComponentClass(or_op.class);} "||" ConditionalAndExpression() )*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void ConditionalAndExpression() : {/*@bgen(jjtree) ConditionalAndExpression */
  SimpleNode jjtn000 = new SimpleNode(this, JJTCONDITIONALANDEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ConditionalAndExpression */
  try {
/*@egen*/
  InclusiveOrExpression() ( {jjtn000.setComponentClass(and_op.class);} "&&" InclusiveOrExpression() )*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void InclusiveOrExpression() : {/*@bgen(jjtree) InclusiveOrExpression */
  SimpleNode jjtn000 = new SimpleNode(this, JJTINCLUSIVEOREXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) InclusiveOrExpression */
  try {
/*@egen*/
  ExclusiveOrExpression() ( {jjtn000.setComponentClass(or_op.class);} "|" ExclusiveOrExpression() )*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void ExclusiveOrExpression() : {/*@bgen(jjtree) ExclusiveOrExpression */
  SimpleNode jjtn000 = new SimpleNode(this, JJTEXCLUSIVEOREXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ExclusiveOrExpression */
  try {
/*@egen*/
  AndExpression() ( {jjtn000.setComponentClass(and_op.class);} "^" AndExpression() )*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void AndExpression() : {/*@bgen(jjtree) AndExpression */
  SimpleNode jjtn000 = new SimpleNode(this, JJTANDEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) AndExpression */
        try {
/*@egen*/
 	EqualityExpression() 
 	( {jjtn000.setComponentClass(and_op.class);} "&" EqualityExpression() )*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void EqualityExpression() : {/*@bgen(jjtree) EqualityExpression */
  SimpleNode jjtn000 = new SimpleNode(this, JJTEQUALITYEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) EqualityExpression */
        try {
/*@egen*/
	RelationalExpression() 
	( ( 
	"==" {jjtn000.setComponentClass(if_eq_op_s.class);} | 
	"!=" {jjtn000.setComponentClass(if_ne_op_s.class);}
	) RelationalExpression() )*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void RelationalExpression() : {/*@bgen(jjtree) RelationalExpression */
  SimpleNode jjtn000 = new SimpleNode(this, JJTRELATIONALEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) RelationalExpression */
  try {
/*@egen*/
  ShiftExpression() 
  ( ( 
  "<" {jjtn000.setComponentClass(if_lt_op_s.class);} | 
  ">" {jjtn000.setComponentClass(if_gt_op_s.class);} | 
  "<=" {jjtn000.setComponentClass(if_le_op_s.class);}| 
  ">=" {jjtn000.setComponentClass(if_ge_op_s.class);}
  ) ShiftExpression() )*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void ShiftExpression() : {/*@bgen(jjtree) ShiftExpression */
        SimpleNode jjtn000 = new SimpleNode(this, JJTSHIFTEXPRESSION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	Integer amount = null;
}
{/*@bgen(jjtree) ShiftExpression */
  try {
/*@egen*/
  AdditiveExpression() ( ( 
  "<<" {jjtn000.setComponentClass(shl_c_op_s.class);} | 
  ">>" {jjtn000.setComponentClass(shr_c_op_s.class);} | 
  ">>>" //TODO verificar qual dos dois shifts e o correto para a opera\u221a\u00df\u221a\u00a3o sem sinal que est\u221a\u00b0 no VHDL
  ) amount=ConstOrInt() {jjtn000.setStepDelay(amount);} )*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void AdditiveExpression() : {/*@bgen(jjtree) AdditiveExpression */
  SimpleNode jjtn000 = new SimpleNode(this, JJTADDITIVEEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) AdditiveExpression */
  try {
/*@egen*/
  MultiplicativeExpression() ( ( 
  "+" {jjtn000.setComponentClass(add_op_s.class);} | 
  "-" {jjtn000.setComponentClass(sub_op_s.class);}
  ) MultiplicativeExpression() )*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void MultiplicativeExpression() : {/*@bgen(jjtree) MultiplicativeExpression */
        SimpleNode jjtn000 = new SimpleNode(this, JJTMULTIPLICATIVEEXPRESSION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	Integer amount = null;
}
{/*@bgen(jjtree) MultiplicativeExpression */
  try {
/*@egen*/
  UnaryExpression() ( ( 
  "*" {jjtn000.setComponentClass(mult_op_s.class);} | 
  "*@" amount=ConstOrInt() {jjtn000.setStepDelay(amount);} {jjtn000.setComponentClass(mult_op_s_p.class);} | // pipelined multiply 
  "/" {jjtn000.setComponentClass(div_op_s.class);}  
//  "%" {jjtThis.setComponentClass(mod_op_s.class);}
  ) UnaryExpression() )*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void UnaryExpression() : {/*@bgen(jjtree) UnaryExpression */
  SimpleNode jjtn000 = new SimpleNode(this, JJTUNARYEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) UnaryExpression */
  try {
/*@egen*/
  ( 
  "+" | 
  "-" {jjtn000.setComponentClass(neg_op_s.class);}  
  ) UnaryExpression()
|
  PreIncrementExpression()
|
  PreDecrementExpression()
|
  UnaryExpressionNotPlusMinus()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

//TODO talvez convenha remover estas duas opera\u221a\u00df\u221a\u00b5es 

void PreIncrementExpression() : {/*@bgen(jjtree) PreIncrementExpression */
  SimpleNode jjtn000 = new SimpleNode(this, JJTPREINCREMENTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) PreIncrementExpression */
  try {
/*@egen*/
  "++" PrimaryExpression()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void PreDecrementExpression() : {/*@bgen(jjtree) PreDecrementExpression */
  SimpleNode jjtn000 = new SimpleNode(this, JJTPREDECREMENTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) PreDecrementExpression */
  try {
/*@egen*/
  "--" PrimaryExpression()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void UnaryExpressionNotPlusMinus() : {/*@bgen(jjtree) UnaryExpressionNotPlusMinus */
  SimpleNode jjtn000 = new SimpleNode(this, JJTUNARYEXPRESSIONNOTPLUSMINUS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) UnaryExpressionNotPlusMinus */
  try {
/*@egen*/
  ( 
  "~" {jjtn000.setComponentClass(not_op.class);} | 
  "!" {jjtn000.setComponentClass(not_op.class);} 
  ) UnaryExpression()
|
  PostfixExpression()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

//TODO talvez convenha remover estas duas opera\u221a\u00df\u221a\u00b5es 

void PostfixExpression() : {/*@bgen(jjtree) PostfixExpression */
  SimpleNode jjtn000 = new SimpleNode(this, JJTPOSTFIXEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) PostfixExpression */
  try {
/*@egen*/
  PrimaryExpression() [ "++" | "--" ]/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void PrimaryExpression() : {/*@bgen(jjtree) PrimaryExpression */
  SimpleNode jjtn000 = new SimpleNode(this, JJTPRIMARYEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) PrimaryExpression */
        try {
/*@egen*/
	<LPAREN> Expression() <RPAREN> | Literal() | Name()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/ 
}

void Literal() : {/*@bgen(jjtree) Literal */
        SimpleNode jjtn000 = new SimpleNode(this, JJTLITERAL);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	Token t;
}
{/*@bgen(jjtree) Literal */
        try {
/*@egen*/
	(t=<INTEGER_LITERAL> | t=<CHARACTER_LITERAL> | t=<STRING_LITERAL>)/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		jjtn000.jjtSetValue(StringToLong(t.image));
	}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

int ConstOrInt()       : {
	Token t;
	int size = 0;
}
{
	(t=<INTEGER_LITERAL> | t=<IDENTIFIER>)
	{
		if (t.kind == IDENTIFIER) {
			if (allConsts.containsKey(t.image)) {
				size = allConsts.get(t.image);
			}
			else {
				ErrorToken("Const " + t.image + " NOT found!", t);
			}
		}
		else {
			size = StringToInteger(t.image);
		}
		return size;
	}
}

long ConstOrLong()       : {
	Token t;
	long size = 0;
}
{
	(t=<INTEGER_LITERAL> | t=<IDENTIFIER>)
	{
		if (t.kind == IDENTIFIER) {
			if (allConsts.containsKey(t.image)) {
				size = allConsts.get(t.image);
			}
			else {
				ErrorToken("Const " + t.image + " NOT found!", t);
			}
		}
		else {
			size = StringToLong(t.image);
		}
		return size;
	}
}

void Error(String s)       : {} 
{
	{
		System.err.println(s);
		System.exit(1);
	}
}

void ErrorToken(String s, Token t)       : {}
{
	{
		Error(s + " line " + t.beginLine + " column " + t.beginColumn);
	}
}

void Info(String s)       : {} 
{
	{
		System.out.println("parsing: " + s);
	}
}

void InfoToken(String s, Token t)       : {} 
{
	{
		Info(s + " line " + t.beginLine + " column " + t.beginColumn);
	}
}

Integer StringToInteger(String s)       : {}
{
	{
		if (s.length() > 1 && s.charAt(1) == 'x')
			return Integer.parseInt(s.substring(2), 16);
		else
			return Integer.parseInt(s);
	}
}

Long StringToLong(String s)       : {}
{
	{
		if (s.length() > 1 && s.charAt(1) == 'x')
			return Long.parseLong(s.substring(2), 16);
		else
			return Long.parseLong(s);
	}
}