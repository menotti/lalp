/* Copyright (c) 2009 Ricardo Menotti, All Rights Reserved.
 *
 * Permission to use, copy, modify, and distribute this software and its 
 * documentation for NON-COMERCIAL purposes and without fee is hereby granted 
 * provided that this copyright notice appears in all copies.
 *
 * RICARDO MENOTTI MAKES NO REPRESENTATIONS OR WARRANTIES ABOUT THE SUITABILITY
 * OF THE SOFTWARE, EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE 
 * IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, OR 
 * NON-INFRINGEMENT. RICARDO MENOTTI SHALL NOT BE LIABLE FOR ANY DAMAGES 
 * SUFFERED BY LICENSEE AS A RESULT OF USING, MODIFYING OR DISTRIBUTING THIS 
 * SOFTWARE OR ITS DERIVATIVES. 
 */

package br.ufscar.dc.lalp.parser;

import java.io.FileInputStream;
import java.io.InputStream;
import java.util.Hashtable;
import java.util.Map;
import java.util.Vector;

import br.ufscar.dc.lalp.components.*;
import br.ufscar.dc.lalp.core.*;
import br.ufscar.dc.lalp.parser.lang.*;



/**
 * Parser for .ALP files
 * 
 * @author <a href="http://menotti.pro.br/">Ricardo Menotti</a>
 * @author <a href="http://www.dc.ufscar.br/">DC/UFSCar</a>
 * @version January, 2009
 */
public class LangParser {

	/**
	 * The parser for LALP language generated by JavaCC
	 */
	ALPParser parser;
	
	/**
	 * The root for tree generated by JJTree
	 */
	SimpleNode root;
	private int beginDelay = 0, endDelay = 0;
	
	//public LangParser(FileInputStream inStream) {
	public LangParser(InputStream inStream) {
		parser = new ALPParser(inStream);
		try {
			root = parser.Start();
			root.updateConnections();
			root.accessComponents();
			for(SimpleNode n: SimpleNode.allOperations){
				if (n.id == ALPParserTreeConstants.JJTDELAYEXPRESSION) { //TODO *
					if(n.getEndStepDelay() != 0){
						beginDelay = n.getStepDelay();
						endDelay = n.getEndStepDelay();
					}					
				}
			}
			if(endDelay != 0)
				for(int i = beginDelay; i <= endDelay; i++)
					parser.design.add(new Design(root.getIdentifier() + i));
			else
				parser.design.add(new Design(root.getIdentifier()));

		} catch (Exception e) {
			e.printStackTrace();
			//System.exit(1);
		}
	}
	
	public SimpleNode getRoot() {
		return this.root;
	}

	public Design getDesign() {
		return parser.design.firstElement();
	}
	
	public Vector<Design> getDesigns(){
		return parser.design;
	}
	
	public ALPParser getParser() {
		return this.parser;
	}
       

	/**
	 * Create components based on types and access
	 */
	public void createComponents() {
		System.out.print("Instantiating hardware components...");
		try {
			for(int i = 0; i < parser.design.size(); i++){
				SimpleNode.allComponents.add(i, new Hashtable<String, Component>());
				createIOComponents(i);
				createIComponents(i);
				createOperations(i);
			}
			for(int i = 0; i < parser.design.size(); i++){
				if(parser.design.get(i).isSync())
				{
					parser.design.get(i).addGlobalComponent(new input("clk"));
					parser.design.get(i).addGlobalComponent(new input("reset"));
					parser.design.get(i).addGlobalComponent(new input("clear"));
				}
			}
		} catch (Exception e) {
			e.printStackTrace();
			//System.exit(1);
		}
		System.out.println("Ok!");
	}
	
	/**
	 * Create input/output pins
	 */
	@SuppressWarnings("unchecked")
	public void createIOComponents(int designIndex)  {
		// create IOComponents
		for (Map.Entry<String, SimpleNode> e : parser.allPins.entrySet()) {
			String name = e.getKey();
			SimpleNode n = e.getValue();
			Integer width = n.getWidth();
			Class componentClass;
			Component comp = null;
			if (n.getPortType() == PortType.INPUT)
				componentClass = input.class;
			else
				componentClass = output.class;
			try {
				if (width != null && width != 1) {
					comp = (Component)componentClass.getConstructor(String.class, int.class).newInstance(name, width);
				}
				else {
					comp = (Component)componentClass.getConstructor(String.class).newInstance(name);
				}
			}
			catch (Exception ex) {
				ex.printStackTrace();
				//System.exit(1);
			}
			comp = parser.design.get(designIndex).addComponent(comp);
			n.setComponent(comp);
			SimpleNode.allComponents.get(designIndex).put(name, comp);	
			//DEBUG 
//			System.out.println(comp);
		}
	}
	
	//TODO verificar quando há muitas atribuições para identificar multiplexadores
	/**
	 * Create registered variables and multiplexers
	 */
	@SuppressWarnings("unchecked")
	public void createIComponents(int designIndex)  {
		// create IComponents
		for (Map.Entry<String, SimpleNode> e : parser.allVariables.entrySet()) {
			String name = e.getKey();
			SimpleNode n = e.getValue();
			Token t = n.getToken();
			Integer width = n.getWidth();
			Class compClass = n.getComponentClass();
			Component comp = null;
			compClass = reg_op.class;
			boolean isCounter = false;
			boolean isAssign = false;
			boolean isRegMux = false;
			boolean isMemory = false;
			if (SimpleNode.allAccess.get(name) != null) {
				Vector<String> assignments = new Vector<String>();
				if (n.getArraySize() != null) { // memory
					isMemory = true;
				}
				for (SimpleNode a : SimpleNode.allAccess.get(name)) {
					if (a.id == ALPParserTreeConstants.JJTCOUNTER) {
						if (isMemory | isCounter | isAssign | isRegMux) {
							ErrorToken("Duplicate use of variable "+name, a.getToken());
						}
						// update node reference to get counter properties
						a.setWidth(n.getWidth());
						n = a;
						isCounter = true;
					}
					else if (a.id == ALPParserTreeConstants.JJTLHS) {
						if (((SimpleNode)a.jjtGetParent()).getIdentifier().equals("+=")) {
							if (isMemory | isCounter | isAssign | isRegMux) {
								ErrorToken("Duplicate use of variable "+name, a.getToken());
							}
							compClass = add_reg_op_s.class;
							isAssign = true;
						}
						else if (((SimpleNode)a.jjtGetParent()).getIdentifier().equals("-=")) {
							if (isMemory | isCounter | isAssign | isRegMux) {
								ErrorToken("Duplicate use of variable "+name, a.getToken());
							}
							compClass = sub_reg_op_s.class;
							isAssign = true;
						}
						else if (((SimpleNode)a.jjtGetParent()).getConnections().getSecond().id == ALPParserTreeConstants.JJTCONDITIONALEXPRESSION) {
							if (isMemory | isCounter | isAssign | isRegMux) {
								ErrorToken("Duplicate use of variable "+name, a.getToken());
							}
							compClass = null; //reg_mux_op created with operations
							isRegMux = true;
						}
						String port = a.getPort();
						if (port == null)
							port = "DEFAULT";
						if (assignments.contains(a.getPort()))
							ErrorToken("Duplicate use of variable "+name, a.getToken());
						else
							if (!port.equals("reset"))
								assignments.add(port);
					}
				} // for allAccess
				try {
					if (isCounter) {
						comp = new counter(name, width, n.getStepDelay(), n.getInc(), (n.getIncOper().charAt(0)=='-'?1:0), counter.getConditionValue(n.getTermCond()));
					}
					else if (isMemory) {
						comp = new block_ram(name, log2(n.getArraySize()), n.getWidth());
						if (n.getInits() != null) {
							long[] inits = new long[n.getInits().size()];
							for (int i=0; i<n.getInits().size(); i++)
								inits[i] = n.getInits().get(i);
							((block_ram)comp).setInitialValue(inits);
						}
					}
					else if (assignments.size() > 1) {
						comp = new mux_m_op(name, width, assignments.size(), assignments.size()-1);
					}
					else {
						if (compClass != null) {
							comp = (Component)compClass.getConstructor(String.class, long.class).newInstance(name, n.getWidth());
							if (n.jjtGetValue() != null) {
								comp.setInitialValue((Long)n.jjtGetValue());
							}
						}
					}
				}
				catch (Exception ex) {
					ex.printStackTrace();
					//System.exit(1);
				}
				if (comp != null) {
					comp = parser.design.get(designIndex).addComponent(comp);					
					n.setComponent(comp);
					if (parser.allAttribution.containsKey(name))
						comp.setLine(parser.allAttribution.get(name));
					SimpleNode.allComponents.get(designIndex).put(name, comp);
				}
			}
			else {
				Info("variable " + name + " is never used");
			}
		} //for allVariables
	}

	/**
	 * Create operations
	 */
	@SuppressWarnings("unchecked")
	public void createOperations(int designIndex) {
		for (SimpleNode n : SimpleNode.allOperations) {
			int begin = 0, end = 0;
			String name = n.getIdentifier();
			Class compClass = n.getComponentClass();
			Component comp = null;
			Integer width = operationWidth(n, designIndex);
			try {
				if (n.id == ALPParserTreeConstants.JJTDELAYEXPRESSION) {
					if(n.getEndStepDelay() != 0)
						comp = new delay_op(name, width, (Integer)(beginDelay + designIndex));
					else
						comp = new delay_op(name, width, (Integer)n.getStepDelay());
				}
				else if (n.id == ALPParserTreeConstants.JJTSHIFTEXPRESSION) {
					comp = (Component)compClass.getConstructor(String.class, int.class, int.class).newInstance(name, (Integer)n.getStepDelay(), width);
				}
				else if (n.id == ALPParserTreeConstants.JJTMULTIPLICATIVEEXPRESSION && n.getStepDelay() != null) {
					if(n.getEndStepDelay() != 0)
						comp = (Component)compClass.getConstructor(String.class, int.class, int.class).newInstance(name, (Integer)(beginDelay + designIndex), width);
					else
						comp = (Component)compClass.getConstructor(String.class, int.class, int.class).newInstance(name, (Integer)n.getStepDelay(), width);
				}
				else {
					//TODO obviamente o trecho abaixo não funciona para todos os componentes
					comp = (Component)compClass.getConstructor(String.class, int.class).newInstance(name, width);
					//inicialização não funciona para reg_mux_op pois o nó N não contem a declaração do valor inicial
					if (n.jjtGetValue() != null) {
						comp.setInitialValue((Integer)n.jjtGetValue());
					}
				}
			}
			catch (Exception ex) {
				ex.printStackTrace();
				//System.exit(1);
			}
			
			comp = parser.design.get(designIndex).addComponent(comp);
			
			while (SimpleNode.allComponents.get(designIndex).containsKey(name)) {
				name = name + "_";
				//TODO: this must be outside of the loop!?
				comp.setName(name);
				n.setIdentifier(name);
			}
			if (parser.allAttribution.get(name) != null)
				comp.setLine(parser.allAttribution.get(name));
			n.setComponent(comp);
			SimpleNode.allComponents.get(designIndex).put(name, comp);
			//DEBUG 
//			System.out.println(comp);
		}
	}
	
	public int operationWidth(SimpleNode n, int designIndex) {
		SimpleNode refSize = n;
		while (refSize.id != ALPParserTreeConstants.JJTASSIGNMENT && refSize.id != ALPParserTreeConstants.JJTDELAYEXPRESSION && refSize.id != ALPParserTreeConstants.JJTUNARYEXPRESSIONNOTPLUSMINUS) {
			refSize = refSize.getConnections().getParent();
		}
		// obtains parent width
		Integer width=connectionWidth(refSize.getConnections().getFirst(), designIndex);
		// obtains first child width
		Integer firstWidth = connectionWidth(n.getConnections().getFirst(), designIndex);
		Integer secondWidth = connectionWidth(n.getConnections().getSecond(), designIndex);
		if (firstWidth == secondWidth && firstWidth != width)
			width = firstWidth;
		n.setWidth(width);
		if (width != null)
			return width;
		else
			return 0; //FIXME ZERO size bus
	}
	
	public Integer connectionWidth(SimpleNode n, int designIndex) {
		if (n == null)
			return null;
		String name = null, port = null;
		Integer width = null;
		SimpleNode refSize = n;
		IComponent comp;
		Component c;
		name = n.getIdentifier();
		port = n.getPort();
		if (name != null && SimpleNode.allComponents.get(designIndex).containsKey(name)) {
			c = (Component)SimpleNode.allComponents.get(designIndex).get(name);
			if (c instanceof input || c instanceof output) {
				width = c.getWidth();
			}
			else {
				comp = (IComponent)SimpleNode.allComponents.get(designIndex).get(name);
				port = refSize.getPort();
				if (port != null) {
					width = comp.getPort(port).getWidth();
				}
				else if (comp.getDefaultOutput() != null) {
					width = comp.getDefaultOutput().getWidth();
				}
				else {
					width = comp.getWidth();
				}
			}
		}
		else if (name != null && parser.allVariables.containsKey(name)) {
			width = parser.allVariables.get(name).getWidth();
		}
		else if (name != null && parser.allPins.containsKey(name)) {
			width = parser.allPins.get(name).getWidth();
		}
		return width;
	}
	
	public void dump() {
		System.out.println();
		System.out.println("SimpleNode root:");
		root.dump("parsing: ");
		System.out.println();
		System.out.println("SimpleNode connections:");
		root.dumpConnections("parsing: ");
		System.out.println();
		System.out.println("Hashtable<String,Integer> allConsts");
		for (Map.Entry<String, Integer> e : parser.allConsts.entrySet()) {
			System.out.println(e);
		}
		System.out.println();
		System.out.println("Hashtable<String,Integer> allTypedefs");
		for (Map.Entry<String, Integer> e : parser.allTypedefs.entrySet()) {
			System.out.println(e);
		}		
		System.out.println();
		System.out.println("Hashtable<String,Object> allPins");
		for (Map.Entry<String, SimpleNode> e : parser.allPins.entrySet()) {
			System.out.println(e);
		}		
		System.out.println();
		System.out.println("Hashtable<String,Object> allVariables");
		for (Map.Entry<String, SimpleNode> e : parser.allVariables.entrySet()) {
			System.out.println(e);
		}		
		System.out.println();
		System.out.println("Hashtable<String,SimpleNode> allAccess");
		for (Map.Entry<String, Vector<SimpleNode>> e : SimpleNode.allAccess.entrySet()) {
			System.out.println(e.getKey()+":"+e.getValue().size());
			for (SimpleNode n : e.getValue()) {
				System.out.println("\t"+n);
			}
		}
	}
	
	/**
     * Calculate base 2 logarithm for memory sizes
     * @param x value to take log of
     * @return base 2 logarithm.
     */
    private static int log2(Integer x) {
    	// Math.log is base e, natural log, ln
    	double res = Math.log(x)/Math.log(2);
    	return (int)res < res ? (int)res+1 : (int)res;
    }

	final public void Error(String s) {
		System.err.println(s);
		//System.exit(1);
	}

	final public void ErrorToken(String s, Token t) {
		if (t != null)
			Error(s + " line " + t.beginLine + " column " + t.beginColumn);
		else
			Error(s);
	}

	final public void Info(String s) {
		System.out.println("parsing: " + s);
	}

	final public void InfoToken(String s, Token t) {
		if (t != null)
			Info(s + " line " + t.beginLine + " column " + t.beginColumn);
		else
			Info(s);
	}
}
