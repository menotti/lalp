/* Copyright (c) 2009 Ricardo Menotti, All Rights Reserved.
 *
 * Permission to use, copy, modify, and distribute this software and its 
 * documentation for NON-COMERCIAL purposes and without fee is hereby granted 
 * provided that this copyright notice appears in all copies.
 *
 * RICARDO MENOTTI MAKES NO REPRESENTATIONS OR WARRANTIES ABOUT THE SUITABILITY
 * OF THE SOFTWARE, EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE 
 * IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, OR 
 * NON-INFRINGEMENT. RICARDO MENOTTI SHALL NOT BE LIABLE FOR ANY DAMAGES 
 * SUFFERED BY LICENSEE AS A RESULT OF USING, MODIFYING OR DISTRIBUTING THIS 
 * SOFTWARE OR ITS DERIVATIVES. 
 */

const DATASIZE = 1024;

typedef fixed(32,1) int;
typedef fixed(1,0) bit;

adpcm_decoder_alp(in bit init, out int output, out bit done) {
  
	{
		int indexTable[16] = {
			-1, -1, -1, -1, 2, 4, 6, 8,
			-1, -1, -1, -1, 2, 4, 6, 8
		};
		int stepSizeTable[89] = {
			7,		8,		9,		10,		11,		12,		13,		14,		16,		17,
			19,		21,		23,		25,		28,		31,		34,		37,		41,		45,
			50,		55,		60,		66,		73,		80,		88,		97,		107,	118,
			130,	143,	157,	173,	190,	209,	230,	253,	279,	307,
			337,	371,	408,	449,	494,	544,	598,	658,	724,	796,
			876,	963,	1060,	1166,	1282,	1411,	1552,	1707,	1878,	2066,
			2272,	2499,	2749,	3024,	3327,	3660,	4026,	4428,	4871,	5358,
			5894,	6484,	7132,	7845,	8630,	9493,	10442,	11487,	12635,	13899,
			15289,	16818,	18500,	20350,	22385,	24623,	27086,	29794,	32767
		};
		int indata[512] = {
			7,	17,	27,	37,	47,	57,	67,	77,	87,	97,	107,	117,	0,	10,	20,	30,	40,	50,	60,	70,	80,	90,	100,	110,	120,	3,	13,	23,	33,	43,	53,	63,	73,	83,	93,	103,	113,	123,	6,	16,	26,	36,	46,	56,	66,	76,	86,	96,	106,	116,	126,	9,	19,	29,	39,	49,	59,	69,	79,	89,	99,	109,	119,	2,	12,	22,	32,	42,	52,	62,	72,	82,	92,	102,	112,	122,	5,	15,	25,	35,	45,	55,	65,	75,	85,	95,	105,	115,	125,	8,	18,	28,	38,	48,	58,	68,	78,	88,	98,	108,	118,	1,	11,	21,	31,	41,	51,	61,	71,	81,	91,	101,	111,	121,	4,	14,	24,	34,	44,	54,	64,	74,	84,	94,	104,	114,	124,	7,	
			17,	27,	37,	47,	57,	67,	77,	87,	97,	107,	117,	0,	10,	20,	30,	40,	50,	60,	70,	80,	90,	100,	110,	120,	3,	13,	23,	33,	43,	53,	63,	73,	83,	93,	103,	113,	123,	6,	16,	26,	36,	46,	56,	66,	76,	86,	96,	106,	116,	126,	9,	19,	29,	39,	49,	59,	69,	79,	89,	99,	109,	119,	2,	12,	22,	32,	42,	52,	62,	72,	82,	92,	102,	112,	122,	5,	15,	25,	35,	45,	55,	65,	75,	85,	95,	105,	115,	125,	8,	18,	28,	38,	48,	58,	68,	78,	88,	98,	108,	118,	1,	11,	21,	31,	41,	51,	61,	71,	81,	91,	101,	111,	121,	4,	14,	24,	34,	44,	54,	64,	74,	84,	94,	104,	114,	124,	7,	17,	
			27,	37,	47,	57,	67,	77,	87,	97,	107,	117,	0,	10,	20,	30,	40,	50,	60,	70,	80,	90,	100,	110,	120,	3,	13,	23,	33,	43,	53,	63,	73,	83,	93,	103,	113,	123,	6,	16,	26,	36,	46,	56,	66,	76,	86,	96,	106,	116,	126,	9,	19,	29,	39,	49,	59,	69,	79,	89,	99,	109,	119,	2,	12,	22,	32,	42,	52,	62,	72,	82,	92,	102,	112,	122,	5,	15,	25,	35,	45,	55,	65,	75,	85,	95,	105,	115,	125,	8,	18,	28,	38,	48,	58,	68,	78,	88,	98,	108,	118,	1,	11,	21,	31,	41,	51,	61,	71,	81,	91,	101,	111,	121,	4,	14,	24,	34,	44,	54,	64,	74,	84,	94,	104,	114,	124,	7,	17,	27,	
			37,	47,	57,	67,	77,	87,	97,	107,	117,	0,	10,	20,	30,	40,	50,	60,	70,	80,	90,	100,	110,	120,	3,	13,	23,	33,	43,	53,	63,	73,	83,	93,	103,	113,	123,	6,	16,	26,	36,	46,	56,	66,	76,	86,	96,	106,	116,	126,	9,	19,	29,	39,	49,	59,	69,	79,	89,	99,	109,	119,	2,	12,	22,	32,	42,	52,	62,	72,	82,	92,	102,	112,	122,	5,	15,	25,	35,	45,	55,	65,	75,	85,	95,	105,	115,	125,	8,	18,	28,	38,	48,	58,	68,	78,	88,	98,	108,	118,	1,	11,	21,	31,	41,	51,	61,	71,	81,	91,	101,	111,	121,	4,	14,	24,	34,	44,	54,	64,	74,	84,	94,	104,	114,	124,	7,	17,	27,	37
		}; //512
	    int outdata[1024]; //1024 
	   	fixed(9,0) i;
		fixed(11,0) len;
		int sign;		
		int delta, delta2;		
		int valpred, valpred2, valpred3;	
		int vpdiff, vpdiff2, vpdiff3, vpdiff4;
		int index, index2, index3;		
		int inputbuffer;
		bit bufferstep = 1;
		int step;
	}
	
  	counter (len=0; len<DATASIZE; len++@3);
  	len.clk_en = init;
	indata.address = i;
  	
  	//step@1
	inputbuffer = indata.data_out when !bufferstep & (len.step@1);
	
	//step@2
  	delta = bufferstep ? inputbuffer & 0xf : (inputbuffer >> 4) & 0xf when len.step@2;
	i += 1 when !bufferstep & (len.step@2);

  	//step@3
    sign = delta & 8 when len.step@3;
    indexTable.address = delta;
    delta2 = delta & 7 when len.step@3;
    bufferstep = !bufferstep when len.step@3;

	//step@4
    index2 = index + indexTable.data_out when len.step@4;	
    stepSizeTable.address = index;
    
	//step@5
    index3 = index2 < 0 ? 0 : index2 when len.step@5;
	step = stepSizeTable.data_out when len.step@5;
    
    //step@6   
    index = index3 > 88 ? 88 : index3 when len.step@6;
    vpdiff = step >> 3 when len.step@6;

    //step@7
    vpdiff2 = ((delta2@3) & 1) > 0 ? vpdiff + (step >> 2) : vpdiff when len.step@7;

	//step@8
    vpdiff3 = ((delta2@4) & 2) > 0 ? vpdiff + (step >> 1) : vpdiff2 when len.step@8;
	
	//step@9
    vpdiff4 = ((delta2@5) & 4) > 0 ? vpdiff + (step@3) : vpdiff3 when len.step@9;

	// alternativamente, a linha abaixo pode ser utilizada em substituição as 3 anteriores pois representa melhor os IFs aninhados e gera exatamente o mesmo hardware
    //vpdiff4 = ((delta2@5) & 4) > 0 ? vpdiff + (step@3) : (((delta2@4) & 2) > 0 ? vpdiff + (step >> 1) : (((delta2@3) & 1) > 0 ? vpdiff + (step >> 2) : vpdiff)) when len.step@9;
    
    //step@10
    valpred2 = (sign@6) > 0 ? valpred - vpdiff4 : valpred + vpdiff4 when len.step@10;
    
    //step@11
	valpred3 = valpred2 > 32767 ? 32767 : valpred2 when len.step@11;
    
    //step@12
	valpred = valpred3 < -32768 ? -32768 : valpred3 when len.step@12;
    outdata.address = len@12;

	//step@13
	outdata.data_in = valpred when len.step@13;
	    
    output = outdata.data_out;
    done = len.done@11;
}