/* Copyright (c) 2009 Ricardo Menotti, All Rights Reserved.
 *
 * Permission to use, copy, modify, and distribute this software and its 
 * documentation for NON-COMERCIAL purposes and without fee is hereby granted 
 * provided that this copyright notice appears in all copies.
 *
 * RICARDO MENOTTI MAKES NO REPRESENTATIONS OR WARRANTIES ABOUT THE SUITABILITY
 * OF THE SOFTWARE, EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE 
 * IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, OR 
 * NON-INFRINGEMENT. RICARDO MENOTTI SHALL NOT BE LIABLE FOR ANY DAMAGES 
 * SUFFERED BY LICENSEE AS A RESULT OF USING, MODIFYING OR DISTRIBUTING THIS 
 * SOFTWARE OR ITS DERIVATIVES. 
 */

/* C code

#define cols 10
#define rows 10
#define N cols*rows

int main() {
	char in[N]; 
	char out[N]; 
	int H, O, V, i;
	int i00, i01, i02;
	int i10,      i12;
	int i20, i21, i22;
	for (i = 0; i < cols*(rows-2)-2; i++) {
		i00=in[i       ]; i01=in[i       +1]; i02=in[i       +2];
		i10=in[i+  cols];                     i12=in[i+  cols+2];
		i20=in[i+2*cols]; i21=in[i+2*cols+1]; i22=in[i+2*cols+2];
	    H = -   i00 - 2*i01 -   i02 +
            +   i20 + 2*i21 +   i22;
	    V = -   i00         +   i02
	        - 2*i10         + 2*i12
	        -   i20         +   i22;
	    if (H<0)
	       H = -H;
	    if (V<0)
	       V = -V;
	    O = H + V;
	    if (O > 255) O = 255;
	        out[i + 1] = (char)O;
	}
	return O;
}

*/

const DATA_WIDTH = 16;
const ROWS = 10;
const COLS = 10;

typedef fixed(DATA_WIDTH, 1) int;
typedef fixed(1, 0) bit;
typedef fixed(8, 0) byte;

sobel_alp(in bit init, out bit done) {
	{
	
	    int H, O, V, Hpos, Vpos, Otrunk; 
	    int i, addr;
	    int i00, i01, i02;
	    int i10,      i12;
	    int i20, i21, i22;
		int input[100] = {
				50, 65, 62, 83, 34, 45, 96, 67, 18, 29, 
				14,	14, 72, 13, 14, 15, 16, 17, 18, 39, 
				20,	23, 82, 23, 20, 25, 26, 27, 28, 29, 
				54, 12, 72, 83, 34, 45, 96, 97, 18, 29, 
				40,	41, 42, 73, 44, 45, 46, 47, 48, 89, 
				52, 60, 82, 83, 34, 45, 96, 37, 18, 29, 
				60,	69, 62, 66, 64, 65, 64, 67, 68, 69, 
				53, 68, 72, 83, 34, 55, 96, 37, 18, 29, 
				84,	87, 82, 83, 84, 85, 86, 87, 28, 89, 
				95,	96, 92, 93, 94, 95, 96, 97, 38, 99
		};
		int output[100];
	}
	i.clk_en = init;
	counter (i=0; i<78; i+=1@8);
	
	input.address = addr;
	addr = i;
	addr = (i@1) + 1 when i.step@1;
	addr = (i@2) + 2 when i.step@2;
	addr = (i@3) + COLS when i.step@3;
	addr = ((i@4) + COLS) + 2 when i.step@4;
	addr = ((i@5) + COLS) + COLS when i.step@5;
	addr = (((i@6) + COLS) + COLS) + 1 when i.step@6;
	addr = (((i@7) + COLS) + COLS) + 2 when i.step@7;
	
	i00 = input when i.step@2; 
	i01 = input when i.step@3; 
	i02 = input when i.step@4;
	i10 = input when i.step@5;
	i12 = input when i.step@6;
	i20 = input when i.step@7;
	i21 = input when i.step@8;
	i22 = input when i.step@9;
	
	H = ((-i00) + (-2*i01)) + (((-i02) + i20) + (2*i21 + i22));

	V = ((-i00) + i02) + (((-2*i10) + 2*i12) + ((-i20) + i22));
		            
	Hpos = H < 0 ? -H : H;
	Vpos = V < 0 ? -V : V;
	
	O = Hpos + Vpos;
	
	Otrunk = 255;
	Otrunk = O when O > 255;
	
	output.data_in = Otrunk when i.step@13;
	output.address = i@13;
	
	done = i.done@13;
}
