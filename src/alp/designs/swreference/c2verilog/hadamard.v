
/*       This module was generated by c-to-verilog.com
 * THIS SOFTWARE IS PROVIDED BY www.c-to-verilog.com ''AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL c-to-verilog.com BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES)
 * 
 * Found a bug? email info@c-to-verilog.com 
 */


module _Z18fastWalshTransformPjS_j  (clk, reset, rdy,// control 
	mem_h_Input_out0, mem_h_Input_in0, mem_h_Input_addr0, mem_h_Input_mode0, // memport for: h_Input 
	mem_h_Output_out0, mem_h_Output_in0, mem_h_Output_addr0, mem_h_Output_mode0, // memport for: h_Output 
	p_h_Output, p_h_Input, i_log2N, return_value); // params 
 input wire clk;
 input wire reset;
 output rdy;
 reg rdy;
 output [31:0] return_value;
 reg [31:0] return_value;
 input [15:0] p_h_Output;
 input [15:0] p_h_Input;
 input [31:0] i_log2N;
input wire [31:0] mem_h_Input_out0;
output reg [31:0] mem_h_Input_in0;
output reg [15:0] mem_h_Input_addr0;
output reg mem_h_Input_mode0;
input wire [31:0] mem_h_Output_out0;
output reg [31:0] mem_h_Output_in0;
output reg [15:0] mem_h_Output_addr0;
output reg mem_h_Output_mode0;


 reg [31:0] ltmp_0_1;   /*local var*/
 reg i_tmp156;   /*local var*/
 reg [31:0] i_incrementVal24;   /*local var*/
 reg [31:0] i_incrementVal;   /*local var*/
 reg [31:0] i_tmp11___0___;   /*local var*/
 reg [31:0] i_tmp11___1___;   /*local var*/
 reg [31:0] i_tmp6___0___;   /*local var*/
 reg i_tmp15___0___;   /*local var*/
 reg [31:0] i_incrementVal61;   /*local var*/
 reg [31:0] i_incrementVal63;   /*local var*/
 reg i_tmp15;   /*local var*/
 reg [31:0] i_indvar_next;   /*local var*/
 reg [31:0] i_tmp6;   /*local var*/
 reg [31:0] i_tmp11;   /*local var*/
 reg i_gluePipelinedLoop67;   /*phi var*/
 reg [31:0] i_gluePipelinedLoop66;   /*phi var*/
 reg [15:0] p_gluePipelinedLoop64;   /*phi var*/
 reg [31:0] i_gluePipelinedLoop62;   /*phi var*/
 reg [15:0] p_gluePipelinedLoop;   /*phi var*/
 reg [31:0] i_pos_01_0;   /*phi var*/
 reg i_tmp7515;   /*local var*/
 reg [31:0] i_tmp25;   /*local var*/
 reg [31:0] i_tmp30;   /*local var*/
 reg [31:0] i_tmp52;   /*local var*/
 reg [31:0] i_indvar_next21;   /*local var*/
 reg i_tmp56;   /*local var*/
 reg [31:0] i_tmp34;   /*local var*/
 reg [31:0] i_tmp38;   /*local var*/
 reg [31:0] i_tmp41;   /*local var*/
 reg [31:0] i_tmp47;   /*local var*/
 reg [31:0] i_j_07;   /*phi var*/
 reg [31:0] i_tmp63;   /*local var*/
 reg [31:0] i_indvar_next23;   /*local var*/
 reg i_tmp67;   /*local var*/
 reg [31:0] ltmp_1_1;   /*local var*/
 reg [31:0] i_tmp28;   /*local var*/
 reg [31:0] i_indvar;   /*phi var*/
 reg i_tmp75;   /*local var*/
 reg i_tmp568;   /*local var*/
 reg [31:0] i_tmp61;   /*local var*/
 reg [31:0] i_stride_014_in;   /*phi var*/
 reg [31:0] i_stride_0_in12;   /*phi var*/

 // Number of states:42
 reg [5:0] eip;
 parameter entry0 = 6'd0;
 parameter entry1 = 6'd1;
 parameter entry2 = 6'd2;
 parameter entry3 = 6'd3;
 parameter entry4 = 6'd4;
 parameter entry5 = 6'd5;
 parameter entry6 = 6'd6;
 parameter entry7 = 6'd7;
 parameter bb_preheader0 = 6'd8;
 parameter bb_preheader1 = 6'd9;
 parameter bb_preheader2 = 6'd10;
 parameter bb_preheader3 = 6'd11;
 parameter PipelinedLoop0 = 6'd12;
 parameter PipelinedLoop1 = 6'd13;
 parameter PipelinedLoop2 = 6'd14;
 parameter bb73_preheader0 = 6'd15;
 parameter bb73_preheader1 = 6'd16;
 parameter bb64_preheader_preheader0 = 6'd17;
 parameter bb220 = 6'd18;
 parameter bb221 = 6'd19;
 parameter bb222 = 6'd20;
 parameter bb223 = 6'd21;
 parameter bb224 = 6'd22;
 parameter bb225 = 6'd23;
 parameter bb226 = 6'd24;
 parameter bb227 = 6'd25;
 parameter bb590 = 6'd26;
 parameter bb591 = 6'd27;
 parameter bb592 = 6'd28;
 parameter bb53_preheader0 = 6'd29;
 parameter bb53_preheader1 = 6'd30;
 parameter bb53_preheader2 = 6'd31;
 parameter bb53_preheader3 = 6'd32;
 parameter bb53_preheader4 = 6'd33;
 parameter bb53_preheader5 = 6'd34;
 parameter bb53_preheader6 = 6'd35;
 parameter bb73_loopexit0 = 6'd36;
 parameter bb73_loopexit1 = 6'd37;
 parameter bb64_preheader0 = 6'd38;
 parameter bb64_preheader1 = 6'd39;
 parameter bb53_preheader_preheader0 = 6'd40;
 parameter bb780 = 6'd41;

// Assign part (2)
wire [31:0] mul0_in_a;
wire [31:0] mul0_in_b;
 assign mul0_in_a = 
 (eip == bb53_preheader0) ? i_indvar :0;
 assign mul0_in_b = 
 (eip == bb53_preheader0) ? i_tmp61 :0;

wire [31:0] out_mul0;
mul  mul0_instance (.clk(clk), .a(mul0_in_a), .b(mul0_in_b), .p(out_mul0));

wire [31:0] shl0_in_a;
wire [31:0] shl0_in_b;
 assign shl0_in_a = 
 (eip == entry0) ? (1) :0;
 assign shl0_in_b = 
 (eip == entry0) ? i_log2N :0;

wire [31:0] out_shl0;
shl  shl0_instance (.clk(clk), .a(shl0_in_a), .b(shl0_in_b), .p(out_shl0));



always @(posedge clk)
 begin
  if (reset)
   begin
    $display("@hard reset");
    eip<=0;
    rdy<=0;
   end


// Datapath 
i_tmp156 <= (ltmp_0_1 == (0));
i_incrementVal24 <= (0)+(0);
i_incrementVal <= (1)+(0);
i_tmp11___0___ <= i_incrementVal24+(1);
i_tmp11___1___ <= i_incrementVal+(1);
i_tmp15___0___ <= (i_tmp11___0___ < ltmp_0_1);
i_incrementVal61 <= (2)+i_pos_01_0;
i_incrementVal63 <= (1)+i_pos_01_0;
i_tmp15 <= (i_gluePipelinedLoop66 < ltmp_0_1);
i_indvar_next <= i_pos_01_0+(1);
i_tmp11 <= i_incrementVal61+(1);
i_tmp7515 <= (ltmp_0_1 < (2));
i_tmp25 <= i_j_07+ltmp_1_1;
i_tmp30 <= i_tmp28+i_j_07;
i_tmp52 <= i_j_07+(1);
i_indvar_next21 <= i_j_07+(1);
i_tmp56 <= (i_tmp52 < (((i_stride_014_in) >> ((1)))));
i_tmp41 <= i_tmp38+i_tmp34;
i_tmp47 <= i_tmp34-i_tmp38;
i_tmp63 <= ltmp_1_1+i_tmp61;
i_indvar_next23 <= i_indvar+(1);
i_tmp67 <= (i_tmp63 < ltmp_0_1);
i_tmp28 <= ltmp_1_1+(((i_stride_014_in) >> ((1))));
i_tmp75 <= ((((i_stride_014_in) >> ((1)))) < (2));
i_tmp568 <= (i_stride_014_in < (2));
i_tmp61 <= i_stride_0_in12&(-2);


// Control 
case (eip)
entry0:
begin
	eip <= entry1;
end
entry1:
begin
	eip <= entry2;
end
entry2:
begin
	eip <= entry3;
end
entry3:
begin
	eip <= entry4;
end
entry4:
begin
	eip <= entry5;
end
entry5:
begin
	ltmp_0_1 <= out_shl0;
	eip <= entry6;
end
entry6:
begin
	eip <= entry7;
end
entry7:
begin
	if (i_tmp156) begin
		eip <= bb73_preheader0;
	end else begin
		eip <= bb_preheader0;
	end
end
bb_preheader0:
begin
	eip <= bb_preheader1;
end
bb_preheader1:
begin
	mem_h_Input_mode0 <= 0;
	mem_h_Input_addr0 <= (p_h_Input + i_incrementVal24);
	eip <= bb_preheader2;
end
bb_preheader2:
begin
	i_tmp6___0___ <= mem_h_Input_out0;
	eip <= bb_preheader3;
end
bb_preheader3:
begin
			i_gluePipelinedLoop67 <= i_tmp15___0___;
		i_gluePipelinedLoop66 <= i_tmp11___1___;
		p_gluePipelinedLoop64 <= (p_h_Output + i_incrementVal24);
		i_gluePipelinedLoop62 <= i_tmp6___0___;
		p_gluePipelinedLoop <= (p_h_Input + i_incrementVal);
		i_pos_01_0 <= (0);
		eip <= PipelinedLoop0;
end
PipelinedLoop0:
begin
	mem_h_Input_mode0 <= 0;
	mem_h_Input_addr0 <= p_gluePipelinedLoop;
	mem_h_Output_in0 <= i_gluePipelinedLoop62;
	mem_h_Output_mode0 <= 1;
	mem_h_Output_addr0 <= p_gluePipelinedLoop64;
	eip <= PipelinedLoop1;
end
PipelinedLoop1:
begin
	i_tmp6 <= mem_h_Input_out0;
	mem_h_Output_mode0 <= 0;
	eip <= PipelinedLoop2;
end
PipelinedLoop2:
begin
	if (i_gluePipelinedLoop67) begin
		i_gluePipelinedLoop67 <= i_tmp15;
		i_gluePipelinedLoop66 <= i_tmp11;
		p_gluePipelinedLoop64 <= (p_h_Output + i_incrementVal63);
		i_gluePipelinedLoop62 <= i_tmp6;
		p_gluePipelinedLoop <= (p_h_Input + i_incrementVal61);
		i_pos_01_0 <= i_indvar_next;
		eip <= PipelinedLoop0;
	end else begin
		eip <= bb73_preheader0;
	end
end
bb73_preheader0:
begin
	eip <= bb73_preheader1;
end
bb73_preheader1:
begin
	if ((i_tmp7515 | i_tmp156)) begin
		eip <= bb780;
	end else begin
		eip <= bb64_preheader_preheader0;
	end
end
bb64_preheader_preheader0:
begin
			i_stride_014_in <= ltmp_0_1;
		i_stride_0_in12 <= ltmp_0_1;
		eip <= bb64_preheader0;
end
bb220:
begin
	eip <= bb221;
end
bb221:
begin
	mem_h_Output_mode0 <= 0;
	mem_h_Output_addr0 <= (p_h_Output + i_tmp25);
	eip <= bb222;
end
bb222:
begin
	i_tmp34 <= mem_h_Output_out0;
	mem_h_Output_mode0 <= 0;
	mem_h_Output_addr0 <= (p_h_Output + i_tmp30);
	eip <= bb223;
end
bb223:
begin
	i_tmp38 <= mem_h_Output_out0;
	eip <= bb224;
end
bb224:
begin
	eip <= bb225;
end
bb225:
begin
	mem_h_Output_in0 <= i_tmp41;
	mem_h_Output_mode0 <= 1;
	mem_h_Output_addr0 <= (p_h_Output + i_tmp25);
	eip <= bb226;
end
bb226:
begin
	mem_h_Output_mode0 <= 0;
	mem_h_Output_in0 <= i_tmp47;
	mem_h_Output_mode0 <= 1;
	mem_h_Output_addr0 <= (p_h_Output + i_tmp30);
	eip <= bb227;
end
bb227:
begin
	mem_h_Output_mode0 <= 0;
	if (i_tmp56) begin
		i_j_07 <= i_indvar_next21;
		eip <= bb220;
	end else begin
		eip <= bb590;
	end
end
bb590:
begin
	eip <= bb591;
end
bb591:
begin
	eip <= bb592;
end
bb592:
begin
	if (i_tmp67) begin
		i_indvar <= i_indvar_next23;
		eip <= bb53_preheader0;
	end else begin
		eip <= bb73_loopexit0;
	end
end
bb53_preheader0:
begin
	eip <= bb53_preheader1;
end
bb53_preheader1:
begin
	eip <= bb53_preheader2;
end
bb53_preheader2:
begin
	eip <= bb53_preheader3;
end
bb53_preheader3:
begin
	eip <= bb53_preheader4;
end
bb53_preheader4:
begin
	eip <= bb53_preheader5;
end
bb53_preheader5:
begin
	ltmp_1_1 <= out_mul0;
	eip <= bb53_preheader6;
end
bb53_preheader6:
begin
			i_j_07 <= (0);
		eip <= bb220;
end
bb73_loopexit0:
begin
	eip <= bb73_loopexit1;
end
bb73_loopexit1:
begin
	if (i_tmp75) begin
		eip <= bb780;
	end else begin
		i_stride_014_in <= (((i_stride_014_in) >> ((1))));
		i_stride_0_in12 <= (((i_stride_014_in) >> ((1))));
		eip <= bb64_preheader0;
	end
end
bb64_preheader0:
begin
	eip <= bb64_preheader1;
end
bb64_preheader1:
begin
	if (i_tmp568) begin
		eip <= bb73_loopexit0;
	end else begin
		eip <= bb53_preheader_preheader0;
	end
end
bb53_preheader_preheader0:
begin
			i_indvar <= (0);
		eip <= bb53_preheader0;
end
bb780:
begin
	 rdy <= 1;
 return_value <= (0);
 $display($time, " Return (0x%x) ",(0));
 $finish();
end
 endcase //eip
end //always @(..)

endmodule



// -- Library components --  

module mul (clk, a, b, p);
output reg [31:0] p;
input [31:0] a;
input [31:0] b;
input clk;reg [31:0] t0;
reg [31:0] t1;
reg [31:0] t2;
reg [31:0] t3;
always @(posedge clk)begin
t0 <= a * b;
t1 <= t0;
t2 <= t1;
t3 <= t2;
p <=t3;
end
endmodule


module div (clk, a, b, p);
output reg [31:0] p;
input [31:0] a;
input [31:0] b;
input clk;reg [31:0] t0;
reg [31:0] t1;
reg [31:0] t2;
reg [31:0] t3;
always @(posedge clk)begin
t0 <= a / b;
t1 <= t0;
t2 <= t1;
t3 <= t2;
p <=t3;
end
endmodule


module shl (clk, a, b, p);
output reg [31:0] p;
input [31:0] a;
input [31:0] b;
input clk;reg [31:0] t0;
reg [31:0] t1;
reg [31:0] t2;
reg [31:0] t3;
always @(posedge clk)begin
t0 <= a << b;
t1 <= t0;
t2 <= t1;
t3 <= t2;
p <=t3;
end
endmodule

// Dual port memory block
module xram (out0, din0, addr0, we0, clk0,
           out1, din1, addr1, we1, clk1);
  parameter ADDRESS_WIDTH = 16;
  parameter WORD_WIDTH = 32;
  output [WORD_WIDTH-1:0] out0;
  input [WORD_WIDTH-1:0] din0;
  input [ADDRESS_WIDTH-1:0] addr0;
  input we0;
  input clk0;
  output [WORD_WIDTH-1:0] out1;
  input [WORD_WIDTH-1:0] din1;
  input [ADDRESS_WIDTH-1:0] addr1;
  input we1;
  input clk1;
  reg [WORD_WIDTH-1:0] mem[1<<ADDRESS_WIDTH-1:0];
   integer i;
   initial begin
       for (i = 0; i < (1<<(ADDRESS_WIDTH-1)); i = i + 1) begin
       mem[i] <= i;
     end
   end
  assign out0 = mem[addr0];
  assign out1 = mem[addr1];
  always @(posedge clk0)begin
      if (we0) begin
          mem[addr0] = din0;
          $display($time,"w mem[%d] == %d; in=%d",addr0, mem[addr0],din0);
      end
  end
  always @(posedge clk1)begin
      if (we1) begin
          mem[addr1] = din1;
          $display($time,"w mem[%d] == %d; in=%d",addr0, mem[addr0],din0);
      end 
  end
endmodule

 // Test Bench 


module _Z18fastWalshTransformPjS_j_test;
 wire rdy;
 reg reset, clk;
wire [31:0] mem_h_Input_out0;
wire [31:0] mem_h_Input_in0;
wire [15:0] mem_h_Input_addr0;
wire mem_h_Input_mode0;
wire [31:0] mem_h_Input_out1;
wire [31:0] mem_h_Input_in1;
wire [15:0] mem_h_Input_addr1;
wire mem_h_Input_mode1;
xram ram_h_Input (mem_h_Input_out0, mem_h_Input_in0, mem_h_Input_addr0, mem_h_Input_mode0, clk,
  mem_h_Input_out1, mem_h_Input_in1, mem_h_Input_addr1, mem_h_Input_mode1, clk);


wire [31:0] mem_h_Output_out0;
wire [31:0] mem_h_Output_in0;
wire [15:0] mem_h_Output_addr0;
wire mem_h_Output_mode0;
wire [31:0] mem_h_Output_out1;
wire [31:0] mem_h_Output_in1;
wire [15:0] mem_h_Output_addr1;
wire mem_h_Output_mode1;
xram ram_h_Output (mem_h_Output_out0, mem_h_Output_in0, mem_h_Output_addr0, mem_h_Output_mode0, clk,
  mem_h_Output_out1, mem_h_Output_in1, mem_h_Output_addr1, mem_h_Output_mode1, clk);


 always #5 clk = ~clk;
 reg [15:0] p_h_Output;
 reg [15:0] p_h_Input;
 reg [31:0] i_log2N;
 wire [31:0] return_value;
_Z18fastWalshTransformPjS_j instance1 (clk, reset, rdy,// control 
	mem_h_Input_out0, mem_h_Input_in0, mem_h_Input_addr0, mem_h_Input_mode0, // memport for: h_Input 
	mem_h_Output_out0, mem_h_Output_in0, mem_h_Output_addr0, mem_h_Output_mode0, // memport for: h_Output 
	p_h_Output, p_h_Input, i_log2N, return_value); // params 
initial begin
 clk = 0;
 $monitor("return = %b, 0x%x", rdy,  return_value);

 // Configure the values below to test the module
 p_h_Output <= 0;
 p_h_Input <= 0;
 i_log2N <= 0;
 #5 reset = 1; #5 reset = 0;
end

endmodule //main_test 
