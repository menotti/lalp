
/*       This module was generated by c-to-verilog.com
 * THIS SOFTWARE IS PROVIDED BY www.c-to-verilog.com ''AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL c-to-verilog.com BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES)
 * 
 * Found a bug? email info@c-to-verilog.com 
 */


module _Z16strip_one_packetPhjS_j  (clk, reset, rdy,// control 
	mem_decoded_out0, mem_decoded_in0, mem_decoded_addr0, mem_decoded_mode0, // memport for: decoded 
	mem_raw_out0, mem_raw_in0, mem_raw_addr0, mem_raw_mode0, // memport for: raw 
	p_raw, i_raw_base, p_decoded, i_decoded_base, return_value); // params 
 input wire clk;
 input wire reset;
 output rdy;
 reg rdy;
 output [31:0] return_value;
 reg [31:0] return_value;
 input [15:0] p_raw;
 input [31:0] i_raw_base;
 input [15:0] p_decoded;
 input [31:0] i_decoded_base;
input wire [7:0] mem_decoded_out0;
output reg [7:0] mem_decoded_in0;
output reg [15:0] mem_decoded_addr0;
output reg mem_decoded_mode0;
input wire [7:0] mem_raw_out0;
output reg [7:0] mem_raw_in0;
output reg [15:0] mem_raw_addr0;
output reg mem_raw_mode0;


 reg [7:0] i_tmp4_i;   /*local var*/
 reg i_tmp5_i;   /*local var*/
 reg [31:0] i_i_01_0_i;   /*phi var*/
 reg [31:0] i_tmp9_i;   /*local var*/
 reg [31:0] i_indvar_next9;   /*local var*/
 reg i_tmp12_i;   /*local var*/
 reg [7:0] i_tmp18_i;   /*local var*/
 reg i_not_tmp19_i;   /*local var*/
 reg [31:0] i_tmp14;   /*local var*/
 reg [31:0] i_tmp8;   /*local var*/
 reg [7:0] i_tmp17;   /*local var*/
 reg [7:0] i_tmp11;   /*local var*/
 reg [31:0] i_tmp19;   /*local var*/
 reg [31:0] ltmp_0_1;   /*local var*/
 reg i_tmp22;   /*local var*/
 reg i_tmp466;   /*local var*/
 reg [31:0] i_tmp30;   /*local var*/
 reg [31:0] i_incrementVal21;   /*local var*/
 reg [31:0] i_incrementVal;   /*local var*/
 reg [31:0] i_incrementVal11;   /*local var*/
 reg [31:0] i_tmp31___0___;   /*local var*/
 reg [31:0] i_tmp31___1___;   /*local var*/
 reg [31:0] i_decoded_base_addr_04___0___;   /*local var*/
 reg [31:0] i_tmp42___0___;   /*local var*/
 reg [31:0] i_decoded_base_addr_04___1___;   /*local var*/
 reg [31:0] i_tmp42___1___;   /*local var*/
 reg [31:0] i_tmp31___2___;   /*local var*/
 reg i_tmp46___0___;   /*local var*/
 reg [7:0] i_tmp35___0___;   /*local var*/
 reg [31:0] i_incrementVal68;   /*local var*/
 reg [31:0] i_incrementVal69;   /*local var*/
 reg i_tmp46;   /*local var*/
 reg [31:0] i_indvar_next;   /*local var*/
 reg [7:0] i_tmp35;   /*local var*/
 reg [31:0] i_decoded_base_addr_04;   /*local var*/
 reg [31:0] i_tmp31;   /*local var*/
 reg [31:0] i_tmp42;   /*local var*/
 reg i_gluePipelinedLoop76;   /*phi var*/
 reg [31:0] i_gluePipelinedLoop75;   /*phi var*/
 reg [15:0] p_gluePipelinedLoop73;   /*phi var*/
 reg [7:0] i_gluePipelinedLoop72;   /*phi var*/
 reg [15:0] p_gluePipelinedLoop71;   /*phi var*/
 reg [31:0] i_gluePipelinedLoop70;   /*phi var*/
 reg [31:0] i_gluePipelinedLoop;   /*phi var*/
 reg [31:0] i_i_05;   /*phi var*/
 reg [31:0] i_retval_0;   /*phi var*/

 // Number of states:37
 reg [5:0] eip;
 parameter entry0 = 6'd0;
 parameter bb_i0 = 6'd1;
 parameter bb_i1 = 6'd2;
 parameter bb_i2 = 6'd3;
 parameter bb_i3 = 6'd4;
 parameter cond_next_i0 = 6'd5;
 parameter cond_next_i1 = 6'd6;
 parameter cond_next_i2 = 6'd7;
 parameter bb15_i0 = 6'd8;
 parameter bb15_i1 = 6'd9;
 parameter bb15_i2 = 6'd10;
 parameter bb15_i3 = 6'd11;
 parameter cond_next0 = 6'd12;
 parameter cond_next1 = 6'd13;
 parameter cond_next2 = 6'd14;
 parameter cond_next3 = 6'd15;
 parameter cond_next4 = 6'd16;
 parameter cond_next5 = 6'd17;
 parameter cond_next6 = 6'd18;
 parameter cond_next7 = 6'd19;
 parameter cond_next8 = 6'd20;
 parameter cond_next9 = 6'd21;
 parameter cond_next10 = 6'd22;
 parameter cond_next11 = 6'd23;
 parameter bb43_preheader0 = 6'd24;
 parameter bb43_preheader1 = 6'd25;
 parameter bb_nph0 = 6'd26;
 parameter bb_nph1 = 6'd27;
 parameter bb_nph2 = 6'd28;
 parameter bb_nph3 = 6'd29;
 parameter bb_nph4 = 6'd30;
 parameter PipelinedLoop0 = 6'd31;
 parameter PipelinedLoop1 = 6'd32;
 parameter PipelinedLoop2 = 6'd33;
 parameter return_loopexit0 = 6'd34;
 parameter return_loopexit100 = 6'd35;
 parameter return0 = 6'd36;

// Assign part (1)
wire [31:0] shl0_in_a;
wire [31:0] shl0_in_b;
 assign shl0_in_a = 
 (eip == cond_next4) ? (i_tmp11) :0;
 assign shl0_in_b = 
 (eip == cond_next4) ? i_tmp19 :0;

wire [31:0] out_shl0;
shl  shl0_instance (.clk(clk), .a(shl0_in_a), .b(shl0_in_b), .p(out_shl0));



always @(posedge clk)
 begin
  if (reset)
   begin
    $display("@hard reset");
    eip<=0;
    rdy<=0;
   end


// Datapath 
i_tmp5_i <= (i_tmp4_i == (-86));
i_tmp9_i <= i_i_01_0_i+(1);
i_indvar_next9 <= i_i_01_0_i+(1);
i_tmp12_i <= (i_tmp9_i < (7));
i_not_tmp19_i <= (i_tmp18_i == (-85));
i_tmp14 <= i_raw_base+(21);
i_tmp8 <= i_raw_base+(20);
i_tmp19 <= (i_tmp17)+(8);
i_tmp22 <= (ltmp_0_1 > (1500));
i_tmp466 <= (ltmp_0_1 == (0));
i_tmp30 <= i_raw_base+(22);
i_incrementVal21 <= (0)+(0);
i_incrementVal <= (1)+(0);
i_incrementVal11 <= (2)+(0);
i_tmp31___0___ <= i_tmp30+i_incrementVal21;
i_tmp31___1___ <= i_tmp30+i_incrementVal;
i_decoded_base_addr_04___0___ <= i_incrementVal21+i_decoded_base;
i_tmp42___0___ <= i_incrementVal21+(1);
i_decoded_base_addr_04___1___ <= i_incrementVal+i_decoded_base;
i_tmp42___1___ <= i_incrementVal+(1);
i_tmp31___2___ <= i_tmp30+i_incrementVal11;
i_tmp46___0___ <= (i_tmp42___0___ < ltmp_0_1);
i_incrementVal68 <= (2)+i_i_05;
i_incrementVal69 <= (3)+i_i_05;
i_tmp46 <= (i_gluePipelinedLoop75 < ltmp_0_1);
i_indvar_next <= i_i_05+(1);
i_decoded_base_addr_04 <= i_incrementVal68+i_decoded_base;
i_tmp31 <= i_tmp30+i_incrementVal69;
i_tmp42 <= i_incrementVal68+(1);


// Control 
case (eip)
entry0:
begin
			i_i_01_0_i <= (0);
		eip <= bb_i0;
end
bb_i0:
begin
	mem_raw_mode0 <= 0;
	mem_raw_addr0 <= (p_raw + i_i_01_0_i);
	eip <= bb_i1;
end
bb_i1:
begin
	i_tmp4_i <= mem_raw_out0;
	eip <= bb_i2;
end
bb_i2:
begin
	eip <= bb_i3;
end
bb_i3:
begin
	if (i_tmp5_i) begin
		eip <= cond_next_i0;
	end else begin
		eip <= return_loopexit0;
	end
end
cond_next_i0:
begin
	eip <= cond_next_i1;
end
cond_next_i1:
begin
	eip <= cond_next_i2;
end
cond_next_i2:
begin
	if (i_tmp12_i) begin
		i_i_01_0_i <= i_indvar_next9;
		eip <= bb_i0;
	end else begin
		eip <= bb15_i0;
	end
end
bb15_i0:
begin
	mem_raw_mode0 <= 0;
	mem_raw_addr0 <= (p_raw + (7));
	eip <= bb15_i1;
end
bb15_i1:
begin
	i_tmp18_i <= mem_raw_out0;
	eip <= bb15_i2;
end
bb15_i2:
begin
	eip <= bb15_i3;
end
bb15_i3:
begin
	if (i_not_tmp19_i) begin
		eip <= cond_next0;
	end else begin
		i_retval_0 <= (1);
		eip <= return0;
	end
end
cond_next0:
begin
	eip <= cond_next1;
end
cond_next1:
begin
	mem_raw_mode0 <= 0;
	mem_raw_addr0 <= (p_raw + i_tmp14);
	eip <= cond_next2;
end
cond_next2:
begin
	i_tmp17 <= mem_raw_out0;
	mem_raw_mode0 <= 0;
	mem_raw_addr0 <= (p_raw + i_tmp8);
	eip <= cond_next3;
end
cond_next3:
begin
	i_tmp11 <= mem_raw_out0;
	eip <= cond_next4;
end
cond_next4:
begin
	eip <= cond_next5;
end
cond_next5:
begin
	eip <= cond_next6;
end
cond_next6:
begin
	eip <= cond_next7;
end
cond_next7:
begin
	eip <= cond_next8;
end
cond_next8:
begin
	eip <= cond_next9;
end
cond_next9:
begin
	ltmp_0_1 <= out_shl0;
	eip <= cond_next10;
end
cond_next10:
begin
	eip <= cond_next11;
end
cond_next11:
begin
	if (i_tmp22) begin
		i_retval_0 <= (1);
		eip <= return0;
	end else begin
		eip <= bb43_preheader0;
	end
end
bb43_preheader0:
begin
	eip <= bb43_preheader1;
end
bb43_preheader1:
begin
	if (i_tmp466) begin
		i_retval_0 <= (0);
		eip <= return0;
	end else begin
		eip <= bb_nph0;
	end
end
bb_nph0:
begin
	eip <= bb_nph1;
end
bb_nph1:
begin
	eip <= bb_nph2;
end
bb_nph2:
begin
	mem_raw_mode0 <= 0;
	mem_raw_addr0 <= (p_raw + i_tmp31___0___);
	eip <= bb_nph3;
end
bb_nph3:
begin
	i_tmp35___0___ <= mem_raw_out0;
	eip <= bb_nph4;
end
bb_nph4:
begin
			i_gluePipelinedLoop76 <= i_tmp46___0___;
		i_gluePipelinedLoop75 <= i_tmp42___1___;
		p_gluePipelinedLoop73 <= (p_decoded + i_decoded_base_addr_04___0___);
		i_gluePipelinedLoop72 <= i_tmp35___0___;
		p_gluePipelinedLoop71 <= (p_raw + i_tmp31___1___);
		i_gluePipelinedLoop70 <= i_tmp31___2___;
		i_gluePipelinedLoop <= i_decoded_base_addr_04___1___;
		i_i_05 <= (0);
		eip <= PipelinedLoop0;
end
PipelinedLoop0:
begin
	mem_decoded_in0 <= i_gluePipelinedLoop72;
	mem_decoded_mode0 <= 1;
	mem_decoded_addr0 <= p_gluePipelinedLoop73;
	mem_raw_mode0 <= 0;
	mem_raw_addr0 <= p_gluePipelinedLoop71;
	eip <= PipelinedLoop1;
end
PipelinedLoop1:
begin
	mem_decoded_mode0 <= 0;
	i_tmp35 <= mem_raw_out0;
	eip <= PipelinedLoop2;
end
PipelinedLoop2:
begin
	if (i_gluePipelinedLoop76) begin
		i_gluePipelinedLoop76 <= i_tmp46;
		i_gluePipelinedLoop75 <= i_tmp42;
		p_gluePipelinedLoop73 <= (p_decoded + i_gluePipelinedLoop);
		i_gluePipelinedLoop72 <= i_tmp35;
		p_gluePipelinedLoop71 <= (p_raw + i_gluePipelinedLoop70);
		i_gluePipelinedLoop70 <= i_tmp31;
		i_gluePipelinedLoop <= i_decoded_base_addr_04;
		i_i_05 <= i_indvar_next;
		eip <= PipelinedLoop0;
	end else begin
		eip <= return_loopexit100;
	end
end
return_loopexit0:
begin
			i_retval_0 <= (1);
		eip <= return0;
end
return_loopexit100:
begin
			i_retval_0 <= (0);
		eip <= return0;
end
return0:
begin
	 rdy <= 1;
 return_value <= i_retval_0;
 $display($time, " Return (0x%x) ",i_retval_0);
 $finish();
end
 endcase //eip
end //always @(..)

endmodule



// -- Library components --  

module mul (clk, a, b, p);
output reg [31:0] p;
input [31:0] a;
input [31:0] b;
input clk;reg [31:0] t0;
reg [31:0] t1;
reg [31:0] t2;
reg [31:0] t3;
always @(posedge clk)begin
t0 <= a * b;
t1 <= t0;
t2 <= t1;
t3 <= t2;
p <=t3;
end
endmodule


module div (clk, a, b, p);
output reg [31:0] p;
input [31:0] a;
input [31:0] b;
input clk;reg [31:0] t0;
reg [31:0] t1;
reg [31:0] t2;
reg [31:0] t3;
always @(posedge clk)begin
t0 <= a / b;
t1 <= t0;
t2 <= t1;
t3 <= t2;
p <=t3;
end
endmodule


module shl (clk, a, b, p);
output reg [31:0] p;
input [31:0] a;
input [31:0] b;
input clk;reg [31:0] t0;
reg [31:0] t1;
reg [31:0] t2;
reg [31:0] t3;
always @(posedge clk)begin
t0 <= a << b;
t1 <= t0;
t2 <= t1;
t3 <= t2;
p <=t3;
end
endmodule

// Dual port memory block
module xram (out0, din0, addr0, we0, clk0,
           out1, din1, addr1, we1, clk1);
  parameter ADDRESS_WIDTH = 16;
  parameter WORD_WIDTH = 32;
  output [WORD_WIDTH-1:0] out0;
  input [WORD_WIDTH-1:0] din0;
  input [ADDRESS_WIDTH-1:0] addr0;
  input we0;
  input clk0;
  output [WORD_WIDTH-1:0] out1;
  input [WORD_WIDTH-1:0] din1;
  input [ADDRESS_WIDTH-1:0] addr1;
  input we1;
  input clk1;
  reg [WORD_WIDTH-1:0] mem[1<<ADDRESS_WIDTH-1:0];
   integer i;
   initial begin
       for (i = 0; i < (1<<(ADDRESS_WIDTH-1)); i = i + 1) begin
       mem[i] <= i;
     end
   end
  assign out0 = mem[addr0];
  assign out1 = mem[addr1];
  always @(posedge clk0)begin
      if (we0) begin
          mem[addr0] = din0;
          $display($time,"w mem[%d] == %d; in=%d",addr0, mem[addr0],din0);
      end
  end
  always @(posedge clk1)begin
      if (we1) begin
          mem[addr1] = din1;
          $display($time,"w mem[%d] == %d; in=%d",addr0, mem[addr0],din0);
      end 
  end
endmodule

 // Test Bench 


module _Z16strip_one_packetPhjS_j_test;
 wire rdy;
 reg reset, clk;
wire [7:0] mem_decoded_out0;
wire [7:0] mem_decoded_in0;
wire [15:0] mem_decoded_addr0;
wire mem_decoded_mode0;
wire [7:0] mem_decoded_out1;
wire [7:0] mem_decoded_in1;
wire [15:0] mem_decoded_addr1;
wire mem_decoded_mode1;
xram ram_decoded (mem_decoded_out0, mem_decoded_in0, mem_decoded_addr0, mem_decoded_mode0, clk,
  mem_decoded_out1, mem_decoded_in1, mem_decoded_addr1, mem_decoded_mode1, clk);


wire [7:0] mem_raw_out0;
wire [7:0] mem_raw_in0;
wire [15:0] mem_raw_addr0;
wire mem_raw_mode0;
wire [7:0] mem_raw_out1;
wire [7:0] mem_raw_in1;
wire [15:0] mem_raw_addr1;
wire mem_raw_mode1;
xram ram_raw (mem_raw_out0, mem_raw_in0, mem_raw_addr0, mem_raw_mode0, clk,
  mem_raw_out1, mem_raw_in1, mem_raw_addr1, mem_raw_mode1, clk);


 always #5 clk = ~clk;
 reg [15:0] p_raw;
 reg [31:0] i_raw_base;
 reg [15:0] p_decoded;
 reg [31:0] i_decoded_base;
 wire [31:0] return_value;
_Z16strip_one_packetPhjS_j instance1 (clk, reset, rdy,// control 
	mem_decoded_out0, mem_decoded_in0, mem_decoded_addr0, mem_decoded_mode0, // memport for: decoded 
	mem_raw_out0, mem_raw_in0, mem_raw_addr0, mem_raw_mode0, // memport for: raw 
	p_raw, i_raw_base, p_decoded, i_decoded_base, return_value); // params 
initial begin
 clk = 0;
 $monitor("return = %b, 0x%x", rdy,  return_value);

 // Configure the values below to test the module
 p_raw <= 0;
 i_raw_base <= 0;
 p_decoded <= 0;
 i_decoded_base <= 0;
 #5 reset = 1; #5 reset = 0;
end

endmodule //main_test 
