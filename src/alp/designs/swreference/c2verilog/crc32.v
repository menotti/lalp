
/*       This module was generated by c-to-verilog.com
 * THIS SOFTWARE IS PROVIDED BY www.c-to-verilog.com ''AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL c-to-verilog.com BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES)
 * 
 * Found a bug? email info@c-to-verilog.com 
 */


module _Z5crc32mPhmmPm  (clk, reset, rdy,// control 
	mem_buf_out0, mem_buf_in0, mem_buf_addr0, mem_buf_mode0, // memport for: buf 
	mem_crc_table_out0, mem_crc_table_in0, mem_crc_table_addr0, mem_crc_table_mode0, // memport for: crc_table 
	i_crc, p_buf, i_offset, i_len, p_crc_table, return_value); // params 
 input wire clk;
 input wire reset;
 output rdy;
 reg rdy;
 output [31:0] return_value;
 reg [31:0] return_value;
 input [31:0] i_crc;
 input [15:0] p_buf;
 input [31:0] i_offset;
 input [31:0] i_len;
 input [15:0] p_crc_table;
input wire [7:0] mem_buf_out0;
output reg [7:0] mem_buf_in0;
output reg [15:0] mem_buf_addr0;
output reg mem_buf_mode0;
input wire [31:0] mem_crc_table_out0;
output reg [31:0] mem_crc_table_in0;
output reg [15:0] mem_crc_table_addr0;
output reg mem_crc_table_mode0;


 reg i_tmp238;   /*local var*/
 reg [31:0] i_tmp1not;   /*local var*/
 reg [31:0] i_incrementVal9;   /*local var*/
 reg [7:0] i_reduced_and;   /*local var*/
 reg [31:0] i_incrementVal136;   /*local var*/
 reg [31:0] i_incrementVal;   /*local var*/
 reg [31:0] i_tmp4____1___;   /*local var*/
 reg [31:0] i_tmp19___0___;   /*local var*/
 reg [31:0] i_tmp19___1___;   /*local var*/
 reg i_tmp23___0___;   /*local var*/
 reg [7:0] i_tmp7____1___;   /*local var*/
 reg [31:0] i_tmp11____1___;   /*local var*/
 reg [31:0] i_tmp14____1___;   /*local var*/
 reg [31:0] i_tmp17____1___;   /*local var*/
 reg [31:0] i_incrementVal165;   /*local var*/
 reg [31:0] i_tmp4;   /*local var*/
 reg [7:0] i_reduced_and183;   /*local var*/
 reg [31:0] i_tmp11;   /*local var*/
 reg [31:0] i_tmp17;   /*local var*/
 reg i_tmp23;   /*local var*/
 reg [31:0] i_indvar_next;   /*local var*/
 reg [7:0] i_tmp7;   /*local var*/
 reg [31:0] i_tmp14;   /*local var*/
 reg [31:0] i_tmp19;   /*local var*/
 reg i_gluePipelinedLoop176;   /*phi var*/
 reg [31:0] i_gluePipelinedLoop175;   /*phi var*/
 reg [31:0] i_gluePipelinedLoop174;   /*phi var*/
 reg [31:0] i_gluePipelinedLoop173;   /*phi var*/
 reg [15:0] p_gluePipelinedLoop172;   /*phi var*/
 reg [31:0] i_gluePipelinedLoop171;   /*phi var*/
 reg [31:0] i_gluePipelinedLoop170;   /*phi var*/
 reg [31:0] i_gluePipelinedLoop169;   /*phi var*/
 reg [7:0] i_gluePipelinedLoop168;   /*phi var*/
 reg [15:0] p_gluePipelinedLoop167;   /*phi var*/
 reg [31:0] i_gluePipelinedLoop166;   /*phi var*/
 reg [31:0] i_gluePipelinedLoop;   /*phi var*/
 reg [31:0] i_i_01_0;   /*phi var*/
 reg [31:0] i_crc_addr_04_0;   /*phi var*/
 reg [31:0] i_tmp26not;   /*local var*/
 reg [31:0] i_crc_addr_04_1;   /*phi var*/

 // Number of states:17
 reg [4:0] eip;
 parameter entry0 = 5'd0;
 parameter entry1 = 5'd1;
 parameter bb_preheader0 = 5'd2;
 parameter bb_preheader1 = 5'd3;
 parameter bb_preheader2 = 5'd4;
 parameter bb_preheader3 = 5'd5;
 parameter bb_preheader4 = 5'd6;
 parameter bb_preheader5 = 5'd7;
 parameter bb_preheader6 = 5'd8;
 parameter bb_preheader7 = 5'd9;
 parameter bb_preheader8 = 5'd10;
 parameter PipelinedLoop0 = 5'd11;
 parameter PipelinedLoop1 = 5'd12;
 parameter PipelinedLoop2 = 5'd13;
 parameter bb25_loopexit0 = 5'd14;
 parameter bb250 = 5'd15;
 parameter bb251 = 5'd16;

// Assign part (0)


always @(posedge clk)
 begin
  if (reset)
   begin
    $display("@hard reset");
    eip<=0;
    rdy<=0;
   end


// Datapath 
i_tmp238 <= (i_len == (0));
i_tmp1not <= i_crc^(-1);
i_incrementVal9 <= (-1)+(0);
i_reduced_and <= ((255))&(i_tmp1not);
i_incrementVal136 <= (0)+(0);
i_incrementVal <= (1)+(0);
i_tmp4____1___ <= i_incrementVal9+i_offset;
i_tmp19___0___ <= i_incrementVal136+(1);
i_tmp19___1___ <= i_incrementVal+(1);
i_tmp23___0___ <= (i_tmp19___0___ < i_len);
i_tmp11____1___ <= (i_tmp7____1___)^(i_reduced_and);
i_tmp17____1___ <= i_tmp14____1___^(((i_tmp1not) >> ((8))));
i_incrementVal165 <= (2)+i_i_01_0;
i_tmp4 <= i_i_01_0+i_offset;
i_reduced_and183 <= ((255))&(i_crc_addr_04_0);
i_tmp11 <= i_gluePipelinedLoop169^i_gluePipelinedLoop170;
i_tmp17 <= i_gluePipelinedLoop173^i_gluePipelinedLoop174;
i_tmp23 <= (i_gluePipelinedLoop < i_len);
i_indvar_next <= i_i_01_0+(1);
i_tmp19 <= i_incrementVal165+(1);
i_tmp26not <= i_crc_addr_04_1^(-1);


// Control 
case (eip)
entry0:
begin
	eip <= entry1;
end
entry1:
begin
	if (i_tmp238) begin
		i_crc_addr_04_1 <= i_tmp1not;
		eip <= bb250;
	end else begin
		eip <= bb_preheader0;
	end
end
bb_preheader0:
begin
	eip <= bb_preheader1;
end
bb_preheader1:
begin
	eip <= bb_preheader2;
end
bb_preheader2:
begin
	mem_buf_mode0 <= 0;
	mem_buf_addr0 <= (p_buf + i_tmp4____1___);
	eip <= bb_preheader3;
end
bb_preheader3:
begin
	i_tmp7____1___ <= mem_buf_out0;
	eip <= bb_preheader4;
end
bb_preheader4:
begin
	eip <= bb_preheader5;
end
bb_preheader5:
begin
	mem_crc_table_mode0 <= 0;
	mem_crc_table_addr0 <= (p_crc_table + i_tmp11____1___);
	eip <= bb_preheader6;
end
bb_preheader6:
begin
	i_tmp14____1___ <= mem_crc_table_out0;
	eip <= bb_preheader7;
end
bb_preheader7:
begin
	eip <= bb_preheader8;
end
bb_preheader8:
begin
			i_gluePipelinedLoop176 <= i_tmp23___0___;
		i_gluePipelinedLoop175 <= i_tmp17____1___;
		i_gluePipelinedLoop174 <= (((i_tmp1not) >> ((8))));
		i_gluePipelinedLoop173 <= i_tmp14____1___;
		p_gluePipelinedLoop172 <= (p_crc_table + i_tmp11____1___);
		i_gluePipelinedLoop171 <= i_tmp11____1___;
		i_gluePipelinedLoop170 <= (i_reduced_and);
		i_gluePipelinedLoop169 <= (i_tmp7____1___);
		i_gluePipelinedLoop168 <= i_tmp7____1___;
		p_gluePipelinedLoop167 <= (p_buf + i_tmp4____1___);
		i_gluePipelinedLoop166 <= i_tmp4____1___;
		i_gluePipelinedLoop <= i_tmp19___1___;
		i_i_01_0 <= (0);
		i_crc_addr_04_0 <= i_tmp1not;
		eip <= PipelinedLoop0;
end
PipelinedLoop0:
begin
	mem_buf_mode0 <= 0;
	mem_buf_addr0 <= p_gluePipelinedLoop167;
	mem_crc_table_mode0 <= 0;
	mem_crc_table_addr0 <= p_gluePipelinedLoop172;
	eip <= PipelinedLoop1;
end
PipelinedLoop1:
begin
	i_tmp7 <= mem_buf_out0;
	i_tmp14 <= mem_crc_table_out0;
	eip <= PipelinedLoop2;
end
PipelinedLoop2:
begin
	if (i_gluePipelinedLoop176) begin
		i_gluePipelinedLoop176 <= i_tmp23;
		i_gluePipelinedLoop175 <= i_tmp17;
		i_gluePipelinedLoop174 <= (((i_crc_addr_04_0) >> ((8))));
		i_gluePipelinedLoop173 <= i_tmp14;
		p_gluePipelinedLoop172 <= (p_crc_table + i_gluePipelinedLoop171);
		i_gluePipelinedLoop171 <= i_tmp11;
		i_gluePipelinedLoop170 <= (i_reduced_and183);
		i_gluePipelinedLoop169 <= (i_gluePipelinedLoop168);
		i_gluePipelinedLoop168 <= i_tmp7;
		p_gluePipelinedLoop167 <= (p_buf + i_gluePipelinedLoop166);
		i_gluePipelinedLoop166 <= i_tmp4;
		i_gluePipelinedLoop <= i_tmp19;
		i_i_01_0 <= i_indvar_next;
		i_crc_addr_04_0 <= i_gluePipelinedLoop175;
		eip <= PipelinedLoop0;
	end else begin
		eip <= bb25_loopexit0;
	end
end
bb25_loopexit0:
begin
			i_crc_addr_04_1 <= i_gluePipelinedLoop175;
		eip <= bb250;
end
bb250:
begin
	eip <= bb251;
end
bb251:
begin
	 rdy <= 1;
 return_value <= i_tmp26not;
 $display($time, " Return (0x%x) ",i_tmp26not);
 $finish();
end
 endcase //eip
end //always @(..)

endmodule



// -- Library components --  

module mul (clk, a, b, p);
output reg [31:0] p;
input [31:0] a;
input [31:0] b;
input clk;reg [31:0] t0;
reg [31:0] t1;
reg [31:0] t2;
reg [31:0] t3;
always @(posedge clk)begin
t0 <= a * b;
t1 <= t0;
t2 <= t1;
t3 <= t2;
p <=t3;
end
endmodule


module div (clk, a, b, p);
output reg [31:0] p;
input [31:0] a;
input [31:0] b;
input clk;reg [31:0] t0;
reg [31:0] t1;
reg [31:0] t2;
reg [31:0] t3;
always @(posedge clk)begin
t0 <= a / b;
t1 <= t0;
t2 <= t1;
t3 <= t2;
p <=t3;
end
endmodule


module shl (clk, a, b, p);
output reg [31:0] p;
input [31:0] a;
input [31:0] b;
input clk;reg [31:0] t0;
reg [31:0] t1;
reg [31:0] t2;
reg [31:0] t3;
always @(posedge clk)begin
t0 <= a << b;
t1 <= t0;
t2 <= t1;
t3 <= t2;
p <=t3;
end
endmodule

// Dual port memory block
module xram (out0, din0, addr0, we0, clk0,
           out1, din1, addr1, we1, clk1);
  parameter ADDRESS_WIDTH = 16;
  parameter WORD_WIDTH = 32;
  output [WORD_WIDTH-1:0] out0;
  input [WORD_WIDTH-1:0] din0;
  input [ADDRESS_WIDTH-1:0] addr0;
  input we0;
  input clk0;
  output [WORD_WIDTH-1:0] out1;
  input [WORD_WIDTH-1:0] din1;
  input [ADDRESS_WIDTH-1:0] addr1;
  input we1;
  input clk1;
  reg [WORD_WIDTH-1:0] mem[1<<ADDRESS_WIDTH-1:0];
   integer i;
   initial begin
       for (i = 0; i < (1<<(ADDRESS_WIDTH-1)); i = i + 1) begin
       mem[i] <= i;
     end
   end
  assign out0 = mem[addr0];
  assign out1 = mem[addr1];
  always @(posedge clk0)begin
      if (we0) begin
          mem[addr0] = din0;
          $display($time,"w mem[%d] == %d; in=%d",addr0, mem[addr0],din0);
      end
  end
  always @(posedge clk1)begin
      if (we1) begin
          mem[addr1] = din1;
          $display($time,"w mem[%d] == %d; in=%d",addr0, mem[addr0],din0);
      end 
  end
endmodule

 // Test Bench 


module _Z5crc32mPhmmPm_test;
 wire rdy;
 reg reset, clk;
wire [7:0] mem_buf_out0;
wire [7:0] mem_buf_in0;
wire [15:0] mem_buf_addr0;
wire mem_buf_mode0;
wire [7:0] mem_buf_out1;
wire [7:0] mem_buf_in1;
wire [15:0] mem_buf_addr1;
wire mem_buf_mode1;
xram ram_buf (mem_buf_out0, mem_buf_in0, mem_buf_addr0, mem_buf_mode0, clk,
  mem_buf_out1, mem_buf_in1, mem_buf_addr1, mem_buf_mode1, clk);


wire [31:0] mem_crc_table_out0;
wire [31:0] mem_crc_table_in0;
wire [15:0] mem_crc_table_addr0;
wire mem_crc_table_mode0;
wire [31:0] mem_crc_table_out1;
wire [31:0] mem_crc_table_in1;
wire [15:0] mem_crc_table_addr1;
wire mem_crc_table_mode1;
xram ram_crc_table (mem_crc_table_out0, mem_crc_table_in0, mem_crc_table_addr0, mem_crc_table_mode0, clk,
  mem_crc_table_out1, mem_crc_table_in1, mem_crc_table_addr1, mem_crc_table_mode1, clk);


 always #5 clk = ~clk;
 reg [31:0] i_crc;
 reg [15:0] p_buf;
 reg [31:0] i_offset;
 reg [31:0] i_len;
 reg [15:0] p_crc_table;
 wire [31:0] return_value;
_Z5crc32mPhmmPm instance1 (clk, reset, rdy,// control 
	mem_buf_out0, mem_buf_in0, mem_buf_addr0, mem_buf_mode0, // memport for: buf 
	mem_crc_table_out0, mem_crc_table_in0, mem_crc_table_addr0, mem_crc_table_mode0, // memport for: crc_table 
	i_crc, p_buf, i_offset, i_len, p_crc_table, return_value); // params 
initial begin
 clk = 0;
 $monitor("return = %b, 0x%x", rdy,  return_value);

 // Configure the values below to test the module
 i_crc <= 1234567890;
 p_buf <= 0;
 i_offset <= 0;
 i_len <= 10;
 p_crc_table <= 0;
 #5 reset = 1; #5 reset = 0;
end

endmodule //main_test 
